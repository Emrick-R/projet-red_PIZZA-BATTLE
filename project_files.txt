// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\affichage\affichage.go
package affichage

import "fmt"

// Separator affiche une sÃ©rie de =
func Separator() {
	fmt.Println("==================================================")
}

// AffichageMenuDemarrage affiche le menu de dÃ©marrage
func AffichageMenuDemarrage() {
	Separator()
	fmt.Println("ğŸ• BIENVENUE DANS PIZZA BATTLE ğŸ•")
	Separator()
	fmt.Println("1 - Commencer une nouvelle partie")
	fmt.Println("2 - Quitter")
	Separator()
}

// AffichageMenuPrincipal affiche le menu principal
func AffichageMenuPrincipal() {
	Separator()
	fmt.Println("ğŸ‘¤ Menu Principal :")
	Separator()
	fmt.Println("1 - Afficher le personnage")
	fmt.Println("2 - Inventaire")
	fmt.Println("3 - Combat en 1 contre 1")
	fmt.Println("4 - Marchand")
	fmt.Println("5 - Forgeron")
	fmt.Println("6 - RETOUR")
	Separator()
}

//AffichageMenuInventaire affiche le menu de l'inventaire
func AffichageMenuInventaire() {
	Separator()
	fmt.Println("ğŸ’ Inventaire :")
	Separator()
	fmt.Println("1 - Utiliser une potion")
	fmt.Println("2 - Equiper un Ã©quipement")
	fmt.Println("3 - RETOUR")
	Separator()
}

//AffichageMenuCombatPotion affiche le menu des potions uniquement lors des combats
func AffichageMenuCombatPotion() {
	Separator()
	fmt.Println("ğŸ§ª Utiliser une potion :")
	Separator()
	fmt.Println("1 - Potion de soin")
	fmt.Println("2 - Potion de poison")
	fmt.Println("3 - RETOUR")
	Separator()
}

//CharacterTurn affiche le menu lors du tour du joueur dans un combat
func CharacterTurn() {
	Separator()
	fmt.Println("âš”ï¸  Combat :")
	Separator()
	fmt.Println("1 - Attaquer")
	fmt.Println("2 - Inventaire")
	fmt.Println("3 - RETOUR")
	Separator()
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\character\character.go
package character

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/affichage"
	"projet-red_PIZZA-BATTLE/inventory"
	"projet-red_PIZZA-BATTLE/items"
	"projet-red_PIZZA-BATTLE/structures"
)

// DisplayCInfo affiche les informations du personnage (nom, classe, PV, niveau, expÃ©rience, argent, initiative, score)
func DisplayCInfo(c *structures.Character) {
	affichage.Separator()
	fmt.Println("ğŸ‘¤ Informations du personnage :")
	affichage.Separator()
	fmt.Printf("ğŸ“› Nom : %s\n", c.Name)
	fmt.Printf("ğŸ¹ Classe : %s\n", c.Class)
	fmt.Printf("â¤ï¸ PV : %d/%d\n", c.ActualHp, c.MaxHp)
	fmt.Printf("ğŸ”µ Mana : %d\n", c.ManaMax)
	fmt.Printf("â­ Niveau : %d\n", c.Level)
	fmt.Printf("ğŸ“š ExpÃ©rience : %d/%d\n", c.ActualExp, c.MaxExp)
	fmt.Printf("ğŸ’° Argent : %d\n", c.Money)
	fmt.Printf("âš¡ Initiative : %d\n", c.Initiative)
	fmt.Printf("ğŸ† Score : %d\n", c.Score)
	affichage.Separator()
}

// DisplayEInfo affiche les informations de l'ennemi (nom, PV, initiative)
func DisplayEInfo(e *structures.Enemy) {
	affichage.Separator()
	fmt.Println("ğŸ‘¹ Informations de l'ennemi :")
	affichage.Separator()
	fmt.Printf("ğŸ“› Nom : %s\n", e.Name)
	fmt.Printf("â¤ï¸ PV : %d/%d\n", e.ActualHp, e.MaxHp)
	fmt.Printf("âš¡ Initiative : %d\n", e.Initiative)
	affichage.Separator()
}

// AccessInventory affiche le contenu de l'inventaire du personnage (nom et quantitÃ© des objets)
func AccessInventory(c *structures.Character) {
	affichage.Separator()
	fmt.Println("ğŸ’ Inventaire :")
	affichage.Separator()
	for i := range c.Inventory {
		fmt.Printf("- %s (x%d)\n", c.Inventory[i].Name, c.Inventory[i].Quantity)
	}
}

// AccessSkills affiche la liste des compÃ©tences du personnage (nom et dÃ©gÃ¢ts)
func AccessSkills(c *structures.Character) {
	affichage.Separator()
	fmt.Println("ğŸ“œ CompÃ©tences :")
	affichage.Separator()
	for s := range c.SkillList {
		fmt.Printf("- %s : %d points de dÃ©gÃ¢ts\n", c.SkillList[s].Name, c.SkillList[s].Damage)
	}
	fmt.Println()
}

// AccessEquipement affiche l'Ã©quipement portÃ© par le personnage (nom de l'armure de tÃªte, torse et jambes)
func AccessEquipement(c *structures.Character) {
	affichage.Separator()
	fmt.Println("ğŸ›¡ï¸  Ã‰quipement :")
	affichage.Separator()
	H := c.Armor.Head.Name
	C := c.Armor.Chest.Name
	L := c.Armor.Legs.Name
	if H == "" {
		H = "Rien"
	}
	if C == "" {
		C = "Rien"
	}
	if L == "" {
		L = "Rien"
	}

	fmt.Println("ğŸ‘’ Armure de tÃªte : ", H)
	fmt.Println("ğŸ‘• Armure de torse : ", C)
	fmt.Println("ğŸ‘– Armure de jambes : ", L)

}

// InventoryChoice affiche l'inventaire, les equipements equipÃ©s, la liste des compÃ©tences et
// permet au joueur de choisir une action (utiliser une potion, Ã©quiper un Ã©quipement, ou revenir en arriÃ¨re)
func InventoryChoice(c *structures.Character) {
	for {
		AccessInventory(c)
		AccessEquipement(c)
		AccessSkills(c)
		affichage.AffichageMenuInventaire()
		menuChoice := 0
		fmt.Print("ğŸ‘‰ Ton choix : ")
		fmt.Scan(&menuChoice)
		switch menuChoice {
		case 1:
			// Utiliser une potion
			items.TakePot(c)
		case 2:
			// Equiper un Ã©quipement
			EquipEquipment(c)
		case 3:
		// Retour
		default:
			fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
		}
		if menuChoice == 3 {
			menuChoice = 0
			return
		}
	}
}

// EquipEquipment permet au joueur d'Ã©quiper un Ã©quipement (chapeau, tunique, bottes)
// s'il le possÃ¨de dans son inventaire
func EquipEquipment(c *structures.Character) {
	//Itinialisation des Ã©quipements disponibles
	var newEquipChoice int
	chapAvent := structures.Object{Name: "Chapeau de l'aventurier", Quantity: 1}
	tunAvent := structures.Object{Name: "Tunique de l'aventurier", Quantity: 1}
	botAvent := structures.Object{Name: "Bottes de l'aventurier", Quantity: 1}
	for {
		// Affichage du menu d'Ã©quipement
		affichage.Separator()
		fmt.Println("ğŸ›¡ï¸  Choisis ton Ã©quipement :")
		affichage.Separator()
		fmt.Println("1 - ğŸ‘’ Chapeau de l'aventurier")
		fmt.Println("2 - ğŸ‘• Tunique de l'aventurier")
		fmt.Println("3 - ğŸ‘¢ Bottes de l'aventurier")
		fmt.Println("4 - â¬…ï¸ RETOUR")
		affichage.Separator()

		fmt.Print("ğŸ‘‰ Ton choix : ")
		fmt.Scan(&newEquipChoice)
		// VÃ©rification si le joueur possÃ¨de l'Ã©quipement dans son inventaire
		// Iniatialisation des boolÃ©ens pour savoir si le joueur possÃ¨de l'Ã©quipement
		hadChap := false
		hadTun := false
		hadBot := false
		// Parcours de l'inventaire pour vÃ©rifier la prÃ©sence des Ã©quipements
		// et mise Ã  jour des boolÃ©ens en consÃ©quence
		// Si le joueur possÃ¨de l'Ã©quipement, il peut l'Ã©quiper
		for _, i := range c.Inventory {
			if i.Name == chapAvent.Name {
				hadChap = true
			}
			if i.Name == tunAvent.Name {
				hadTun = true
			}
			if i.Name == botAvent.Name {
				hadBot = true
			}
		}

		// Ã‰quipement de l'objet choisi si le joueur le possÃ¨de
		// Sinon, affichage d'un message d'erreur
		// Retour au menu prÃ©cÃ©dent si le choix est 4
		switch newEquipChoice {
		case 1:
			// Ã‰quiper le chapeau de l'aventurier
			if hadChap {
				// Ajout de l'Ã©quipement Ã  l'inventaire du personnage
				inventory.AddEquipment(c, chapAvent)
			} else {
				// Message d'erreur si le joueur ne possÃ¨de pas l'Ã©quipement
				fmt.Printf("\nâŒ Tu ne possÃ¨des pas : %s\n\n", chapAvent.Name)
			}
		case 2:
			// Ã‰quiper la tunique de l'aventurier
			if hadTun {
				inventory.AddEquipment(c, tunAvent)
			} else {
				fmt.Printf("\nâŒ Tu ne possÃ¨des pas : %s\n\n", tunAvent.Name)
			}
		case 3:
			// Ã‰quiper les bottes de l'aventurier
			if hadBot {
				inventory.AddEquipment(c, botAvent)
			} else {
				fmt.Printf("\nâŒTu ne possÃ¨des pas : %s\n\n", botAvent.Name)
			}
		case 4:

		default:
			fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
		}
		if newEquipChoice == 4 {
			newEquipChoice = 0
			break
		}
	}
}

// CharacterCreation permet de crÃ©er un personnage en choisissant un pseudo et une classe
func CharacterCreation(c *structures.Character) {
	// Initialisation des variables
	var username string
	var valid bool

	// Boucle pour demander un pseudo valide
	for {
		affichage.Separator()
		fmt.Println("âœï¸  CrÃ©ation du personnage")
		affichage.Separator()
		fmt.Print("ğŸ‘‰ Quel est ton pseudo ? ")
		fmt.Scan(&username)
		valid = true
		result := []rune(username)

		// VÃ©rification que le pseudo n'est pas vide et ne contient que des lettres
		if len(result) == 0 {
			fmt.Println("âŒ Le pseudo ne peut pas Ãªtre vide.")
			valid = false
			continue
		}

		// VÃ©rification que chaque caractÃ¨re est une lettre
		for _, r := range result {
			if r < 65 || (r > 90 && r < 97) || r > 122 {
				fmt.Println("âŒ Le pseudo ne doit contenir que des lettres.")
				valid = false
				break
			}
		}

		// Si le pseudo est valide, on le formate (premiÃ¨re lettre majuscule, le reste en minuscule)
		if valid {
			if result[0] >= 97 && result[0] <= 122 {
				result[0] = result[0] - ('a' - 'A')
			}
			for i := 1; i < len(result); i++ {
				if result[i] >= 65 && result[i] <= 90 {
					result[i] = result[i] + ('a' - 'A')
				}
			}

			// Assignation du pseudo au personnage
			username = string(result)
			c.Name = username
			// Sortie de la boucle
			break
		}
	}

	// Choix de la classe du personnage
	fmt.Println("\nPersonnage crÃ©Ã© avec le nom :", c.Name)
	// Initialisation de la variable
	var class_choice int
	// Boucle pour demander un choix de classe valide
	for {
		affichage.Separator()
		fmt.Printf("ğŸ­ %s, quelle classe veux-tu choisir ?\n", c.Name)
		affichage.Separator()
		fmt.Println("1 - ğŸ¹ Elfe : 80 PV Max")
		fmt.Println("2 - â›ï¸ Nain : 120 PV Max")
		fmt.Println("3 - ğŸ§‘ Humain : 100 PV Max")
		affichage.Separator()

		fmt.Print("ğŸ‘‰ Ton choix : ")
		fmt.Scan(&class_choice)

		// VÃ©rification que le choix est valide
		if class_choice >= 1 && class_choice <= 3 {
			// Choix valide, on sort de la boucle
			break
		}
		fmt.Println("âŒ Choix invalide, essaye encore.")
	}

	// Assignation des caractÃ©ristiques en fonction de la classe choisie
	switch class_choice {
	case 1:
		// Classe Elfe (80 PV Max, 40 PV Actuels (on commence avec la moitier des PV max), 120 Mana Max)
		fmt.Println("ğŸŒ¿ Tu as choisi la classe Elfe : agile, prÃ©cis et en communion avec la nature.")
		c.MaxHp = 80
		c.ActualHp = 40
		c.ManaMax = 120
		c.ActualMana = 120
		c.Class = "Elfe"
	case 2:
		// Classe Nain (120 PV Max, 60 PV Actuels, 80 Mana Max)
		fmt.Println("ğŸª“ Tu as choisi la classe Nain : robuste, courageux et maÃ®tre de la forge.")
		c.MaxHp = 120
		c.ActualHp = 60
		c.ManaMax = 80
		c.ActualMana = 80
		c.Class = "Nain"
	case 3:
		// Classe Humain (100 PV Max, 50 PV Actuels, 80 Mana Max)
		fmt.Println("âš”ï¸  Tu as choisi la classe Humain : polyvalent, ingÃ©nieux et dÃ©terminÃ©.")
		c.MaxHp = 100
		c.ActualHp = 50
		c.ManaMax = 80
		c.ActualMana = 80
		c.Class = "Humain"
	}
}

// Fonction pour ajouter de l'experience au personnage en fonction de la difficultÃ© de l'ennemi vaincu
func AddExp(c *structures.Character, e *structures.Enemy) {
	c.ActualExp += e.GiveExp
}

func NextLevel(c *structures.Character) {
	for c.ActualExp >= c.MaxExp {
		// DÃ©duction de l'XP du niveau en cours
		c.ActualExp -= c.MaxExp

		// Monter de niveau
		c.Level++

		// Augmenter les stats
		c.MaxExp = int(float64(c.MaxExp) * 1.25)
		c.ManaMax = c.ManaMax + 20
		c.MaxHp = c.MaxHp + 20
		c.Initiative = int(float64(c.MaxHp) * 1.1)
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\combat\combat.go
package combat

import (
	"fmt"
	"math/rand"
	"os"
	"projet-red_PIZZA-BATTLE/affichage"
	"projet-red_PIZZA-BATTLE/character"
	"projet-red_PIZZA-BATTLE/inventory"
	"projet-red_PIZZA-BATTLE/items"
	"projet-red_PIZZA-BATTLE/score"
	"projet-red_PIZZA-BATTLE/skills"
	"projet-red_PIZZA-BATTLE/structures"
	"time"
)

// Fonction valeur absolue
func abs(x int) int {
	// Si x est nÃ©gatif
	if x < 0 {
		// On retourne son opposÃ©
		return -x
	}
	// Sinon on retourne x
	return x
}

// Fonction pour lancer un dÃ© Ã  100 faces
func rollDice() int {
	// GÃ©nÃ¨re et retourne un nombre alÃ©atoire entre 1 et 100
	return rand.Intn(100) + 1
}

// Fonction pour dÃ©terminer l'initiative en utilisant le mini-jeu "Ã‰preuve de la Mamma"
// Si le joueur gagne, il commence, sinon l'ennemi commence
func InitiativeMamma(c *structures.Character, e *structures.Enemy) bool {

	// Variable du choix du joueur
	var choix int
	affichage.Separator()
	fmt.Println("ğŸŸ©â¬œğŸŸ¥ Ã‰preuve de la Mamma ğŸŸ©â¬œğŸŸ¥")
	affichage.Separator()
	fmt.Println("Choisissez un nombre (1 Ã  100). Celui le plus proche du score de la Mamma commence !")
	// input joueur sÃ©curisÃ©
	for {
		fmt.Print("ğŸ‘‰ Entres ton nombre : ")
		_, err := fmt.Scan(&choix)
		// vÃ©rification de l'input
		if err == nil && choix >= 1 && choix <= 100 {
			// input valide, on sort de la boucle
			break
		}
		fmt.Println("âŒ Valeur invalide ! Tapes un nombre entre 1 et 100.")
	}

	// premier lancer
	mamma := rollDice()
	ennemi := rollDice()

	// affichage clair
	fmt.Printf("ğŸ² Ton nombre : %d | ğŸ² Mamma : %d | ğŸ² Ennemi : %d\n", choix, mamma, ennemi)

	// en cas d'Ã©galitÃ© on relance les dÃ©s
	for choix == ennemi {
		fmt.Println("Ã‰galitÃ© â€” relance du nombre !")
		mamma = rollDice()
		ennemi = rollDice()
		fmt.Printf("ğŸ² Chiffre : %d | ğŸ² Mamma : %d | ğŸ² Ennemi : %d\n", choix, mamma, ennemi)
	}

	// distances absolues (Rappel: la distance est petite == Gagnant)
	distJoueur := abs(choix + c.Initiative - mamma)
	distEnnemi := abs(ennemi + e.Initiative - mamma)

	// affichage du rÃ©sultat

	if distJoueur < distEnnemi {
		// Joueur gagne
		fmt.Printf("âœ… Tu est le plus proche du chiffre de la Mamma avec une distance de %d (Initiative de %d contre %d), vous commencez !\n", distJoueur, c.Initiative, e.Initiative)
		return true
	} else {
		// Ennemi gagne
		fmt.Printf("âŒ L'ennemi est plus proche du chiffre de la Mamma avec une distance de %d (Initiative de %d contre %d), il commence !\n", distEnnemi, e.Initiative, c.Initiative)
		return false
	}
}

// Affichage de l'inventaire disponible uniquement en combat
func DisplayCombatInventory(c *structures.Character, e *structures.Enemy) {
	// Boucle infinie jusqu'au retour
	for {
		// Affichage de l'inventaire via une fonction
		character.AccessInventory(c)

		// Affichage de l'Ã©quipement
		character.AccessEquipement(c)

		// Affichage des compÃ©tences
		character.AccessSkills(c)

		// Affichage des choix
		affichage.AffichageMenuInventaire()
		menuChoice := 0
		fmt.Print("ğŸ‘‰ Ton choix : ")
		fmt.Scan(&menuChoice)
		switch menuChoice {
		case 1:
			// Choix 1 : Utiliser une potion
			for {
				affichage.AffichageMenuCombatPotion()
				menuChoice := 0
				fmt.Print("ğŸ‘‰ Ton choix : ")
				fmt.Scan(&menuChoice)
				switch menuChoice {
				case 1:
					// Utiliser une potion de vie
					items.TakePot(c)
					return
				case 2:
					//Utiliser une potion de poison
					items.ThrowPoisonPot(c, e)
					return
				case 3:
				//Retour
				default:
					// Choix autre que 1, 2 ou 3
					fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
				}

				if menuChoice == 3 {
					//Reset de la variable menuChoice si choix 3
					menuChoice = 0
					//on retourne au menu inventaire
					break
				}
			}
		case 2:
			// Equiper un Ã©quipement
			character.EquipEquipment(c)
		case 3:
			//Retour
		default:
			// Choix autre que 1, 2 ou 3
			fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
		}

		if menuChoice == 3 {
			//Reset de la variable menuChoice si choix 3
			menuChoice = 0
			//on retourne au menu inventaire
			break
		}
	}
}

// VÃ©rification de la mort du personnage avec rÃ©surrection (MaxHp/2), si mort dÃ©finitive (MaxHp <= 10) fin de partie
func CharacterIsDead(c *structures.Character) {
	//VÃ©rification si impossibilitÃ© de renaÃ®tre (MaxHp <= 10)
	if c.MaxHp <= 10 {
		fmt.Println("\nğŸ’€ Tu es mort pour de bon !")
		fmt.Println("ImpossibilitÃ© de renaÃ®tre...")
		fmt.Println("======== Fin de partie ========")
		//Affichage du score final
		score.ShowScore(c)
		//Pause de 7 secondes avant fermeture du programme
		time.Sleep(7 * time.Second)
		os.Exit(0)
	}

	//VÃ©rification de la mort du personnage puis rÃ©surrection avec moitiÃ© des PV max
	if c.ActualHp <= 0 {
		fmt.Println("\nğŸ’€ Tu es mort !")
		//RÃ©surrection avec moitiÃ© des PV max
		c.MaxHp /= 2
		c.ActualHp = c.MaxHp
		fmt.Println("âœ¨ RÃ©surrection avec 50% de HP en moins.")
		fmt.Printf("â¤ï¸ PV actuels: %d/%d\n", c.ActualHp, c.MaxHp)
	}
}

// VÃ©rification de la mort de l'ennemi, si mort renvoie true
func EnemyIsDead(e *structures.Enemy) bool {
	//Si les PV de l'ennemi sont infÃ©rieurs ou Ã©gaux Ã  0
	if e.ActualHp <= 0 {
		fmt.Printf("âš”ï¸  Tu as vaincu %s !\n", e.Name)
		//Ennemi mort donc true
		return true
	}
	//Ennemi toujours en vie donc false
	return false
}

// Comportement de l'ennemi lors de son tour
func EnemyPattern(c *structures.Character, e *structures.Enemy, t int) {
	//Tout les 3 tours l'ennemi fait une attaque spÃ©ciale (double dÃ©gÃ¢ts)
	if e.PowerCount == 3 {
		//Tour SpÃ©cial
		//Remise Ã  0 du compteur
		e.PowerCount = 0
		//DÃ©gÃ¢ts doublÃ©s sur ce tour
		p := e.Damage * 2
		fmt.Printf("ğŸ”¥ %s utilise une ATTAQUE SPÃ‰CIALE sur %s et inflige %d dÃ©gÃ¢ts !\n", e.Name, c.Name, p)
		//Application des dÃ©gÃ¢ts
		c.ActualHp = c.ActualHp - p
		//Affichage des PV restants
		fmt.Printf("â¤ï¸ %s : %d/%d HP\n", c.Name, c.ActualHp, c.MaxHp)
	} else {
		//Autre tours
		//Attaque normale
		c.ActualHp = c.ActualHp - e.Damage
		fmt.Printf("ğŸ‘Š %s attaque %s et inflige %d dÃ©gÃ¢ts\n", e.Name, c.Name, e.Damage)
		fmt.Printf("â¤ï¸ %s : %d/%d HP\n", c.Name, c.ActualHp, c.MaxHp)
		//IncrÃ©mentation du compteur de l'attaque spÃ©ciale
		e.PowerCount++
	}
}

// Tour du personnage
func CharacterTurn(c *structures.Character, e *structures.Enemy) {
	for {
		//Boucle infinie jusqu'Ã  un retour (fin du tour)
		var combat_choice int
		//Affichage du menu combat
		affichage.Separator()
		fmt.Println("âš”ï¸  COMBAT :")
		affichage.Separator()
		fmt.Println("1 - ğŸ—¡ï¸ Attaquer")
		fmt.Println("2 - ğŸ’ Inventaire")

		fmt.Print("ğŸ‘‰ Ton choix : ")
		fmt.Scan(&combat_choice)
		switch combat_choice {
		case 1:
			// Attaque

			// Choix de la compÃ©tence : sors la compÃ©tence choisie
			chosenSkill := skills.SkillChoice(c)

			// VÃ©rification du mana
			skills.CheckMana(c, chosenSkill)
			// DÃ©duction du mana
			c.ActualMana -= chosenSkill.ManaCost
			// Affichage du mana restant
			fmt.Printf("ğŸ”µ Mana restant : %d/%d\n", c.ActualMana, c.ManaMax)
			// Utilisation de la compÃ©tence sur l'ennemi
			skills.UseSkill(c, e, chosenSkill)
			// Affichage des dÃ©gÃ¢ts infligÃ©s et des PV restants de l'ennemi
			fmt.Printf("\nğŸ’¥ %s inflige %d points de dÃ©gÃ¢ts Ã  %s !\n", c.Name, chosenSkill.Damage, e.Name)
			fmt.Printf("â¤ï¸ %s : %d/%d HP\n", e.Name, e.ActualHp, e.MaxHp)
			// Fin du tour du joueur
			return
		case 2:
			for {
				// Affichage de l'inventaire

				// Affichage de l'inventaire via une fonction
				character.AccessInventory(c)
				// Affichage de l'Ã©quipement
				character.AccessEquipement(c)
				// Affichage des compÃ©tences
				character.AccessSkills(c)
				// Affichage des choix
				affichage.AffichageMenuInventaire()
				menuChoice := 0
				fmt.Print("ğŸ‘‰ Ton choix : ")
				fmt.Scan(&menuChoice)
				switch menuChoice {
				case 1:
					for {
						// Affichage des choix de potions
						affichage.AffichageMenuCombatPotion()
						menuChoice := 0
						fmt.Print("ğŸ‘‰ Ton choix : ")
						fmt.Scan(&menuChoice)
						switch menuChoice {
						case 1:
							// Utiliser une potion
							items.TakePot(c)
							// Fin du tour du joueur
							return
						case 2:
							//Utiliser une potion de poison
							items.ThrowPoisonPot(c, e)
							// Fin du tour du joueur
							return
						case 3:
						//Retour
						default:
							// Choix autre que 1, 2 ou 3
							fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
						}
						//Reset de la variable menuChoice
						if menuChoice == 3 {
							menuChoice = 0
							break
						}
					}
				case 2:
					// Equiper un Ã©quipement
					character.EquipEquipment(c)
				case 3:
				// Retour
				default:
					// Choix autre que 1, 2 ou 3
					fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
				}
				//Reset de la variable menuChoice
				if menuChoice == 3 {
					menuChoice = 0
					return
				}
			}
		default:
			// Choix autre que 1 ou 2
			fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
		}

	}
}

// Fonction principale du combat 1v1 entre le personnage et l'ennemi
func TurnCombat1v1(c *structures.Character, e *structures.Enemy) {
	// Initialisation du tour
	Turn := 1
	TrueTurn := 1
	//Initialisation de l'initiative
	if InitiativeMamma(c, e) {
		Turn = 2
	} else {
		Turn = 1
	}
	//Boucle de combat
	for {
		//Le tour du joueur (Turn == pair)
		if Turn%2 == 0 {
			fmt.Printf("ğŸ¯ Tour %d â€” Ã€ ton tour %s !\n", TrueTurn, c.Name)
			//DÃ©roulement du tour du joueur
			CharacterTurn(c, e)
			//VÃ©rification de la mort
			if EnemyIsDead(e) {
				//L'ennemi est mort
				break
			}
			Turn++
			TrueTurn++

		} else {
			//Le tour de l'IA (Turn == impair)
			fmt.Printf("ğŸ¯ Tour %d â€” C'est au tour de %s !\n", TrueTurn, e.Name)
			//Verification de l'effet de poison
			items.CheckPoisonStatus(e)
			if EnemyIsDead(e) {
				//L'ennemi est mort
				break
			}
			//DÃ©roulement du tour de l'IA
			EnemyPattern(c, e, Turn)
			//VÃ©rification de la mort
			CharacterIsDead(c)
			Turn++
			TrueTurn++
		}
	}
	//Fin du combat (ennemi mort)
	fmt.Printf("ğŸ† Bravo ! Tu as terrassÃ© %s !\n", e.Name)
	//RÃ©compenses du combat (Argent + Score)
	score.AddScore(c, e)
	inventory.AddMoney(c, e)
	character.AddExp(c, e)
	fmt.Printf("\nğŸ’° +%d argent", e.GiveMoney)
	fmt.Printf("\nğŸ“š +%d expÃ©rience", e.GiveExp)
	fmt.Printf("\nâ­ +%d points de score\n", e.GiveScore)
	//Affichage de l'argent, de l'Exp et du score
	affichage.Separator()
	character.NextLevel(c)
	fmt.Printf("ğŸ’µ Argent : %d | ğŸ“– Exp : %d | ğŸ… Score : %d\n", c.Money, c.ActualExp, c.Score)
	affichage.Separator()
	// Retour au menu principal
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\forgeron\forgeron.go
package forgeron

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/inventory"
	"projet-red_PIZZA-BATTLE/structures"
)

// Fonction utilitaire pour obtenir le minimum entre deux entiers
func min(a, b int) int {
	// Retourne le plus petit des deux entiers
	if a < b {
		return a
	}
	return b
}

// Forgeron permet au joueur de fabriquer des objets s'il a les matÃ©riaux nÃ©cessaires
func Forgeron(c *structures.Character) {
	// Initialisation des objets nÃ©cessaires Ã  la fabrication et des objets fabriquÃ©s
	// Objets nÃ©cessaires
	wolfFur := structures.Object{Name: "Peau de Loup", Quantity: 1}
	trollSkin := structures.Object{Name: "Peau de Troll", Quantity: 1}
	boarLeather := structures.Object{Name: "Cuir de Sanglier", Quantity: 1}
	ravenFeather := structures.Object{Name: "Plume de Corbeau", Quantity: 1}

	// Objets fabriquÃ©s
	chapeauAventurier := structures.Object{Name: "Chapeau de l'aventurier", Quantity: 1}
	tuniqueAventurier := structures.Object{Name: "Tunique de l'aventurier", Quantity: 1}
	bottesAventurier := structures.Object{Name: "Bottes de l'aventurier", Quantity: 1}

	// Initialisation des variables pour les choix du joueur
	var forgeron_choice int
	var craft_confirmation int

	// Boucle principale du forgeron
	for {
		fmt.Println("======== Forgeron : ========")
		fmt.Println("Bonjour je suis le Forgeron, quel est votre choix ?")
		fmt.Println("1 - Fabrication : Chapeau de l'aventurier (1 Plume de Corbeau + 1 Cuir de Sanglier)")
		fmt.Println("2 - Fabrication : Tunique de l'aventurier (2 Fourrures de Loup + 1 Peau de Troll)")
		fmt.Println("3 - Fabrication : Bottes de l'aventurier (1 Fourrure de Loup + 1 Cuir de Sanglier)")
		fmt.Println("4 - RETOUR")
		fmt.Scan(&forgeron_choice)

		// Initialisation des compteurs pour chaque matÃ©riau
		var countRavenFeather, countBoarLeather, countWolfFur, countTrollSkin int

		// Comptage des matÃ©riaux dans l'inventaire du personnage
		for i := range c.Inventory {
			switch c.Inventory[i].Name {
			case "Plume de Corbeau":
				countRavenFeather = c.Inventory[i].Quantity
			case "Cuir de Sanglier":
				countBoarLeather = c.Inventory[i].Quantity
			case "Peau de Loup":
				countWolfFur = c.Inventory[i].Quantity
			case "Peau de Troll":
				countTrollSkin = c.Inventory[i].Quantity
			}
		}

		// Gestion des choix du joueur pour la fabrication
		switch forgeron_choice {
		case 1:
			// Fabrication du Chapeau de l'aventurier
			// Calcul du nombre d'objets fabriquables en fonction des matÃ©riaux disponibles
			itemcraftable := min(countRavenFeather, countBoarLeather)
			//VÃ©rification si le joueur a les matÃ©riaux nÃ©cessaires
			if itemcraftable < 1 {
				fmt.Printf("\nâŒ Tu n'as pas les objets requis pour fabriquer le Chapeau de l'Aventurier\n\n")
				// Il n'a pas les matÃ©riaux nÃ©cessaires, retour au menu
				break
			} else {
				// Il a les matÃ©riaux nÃ©cessaires, affiche le nombre d'objets fabriquables
				fmt.Printf("\nTu peux fabriquer %dx Chapeau de l'Aventurier, veux-tu en fabriquer 1 ?\n", itemcraftable)
			}

			// Demande de confirmation au joueur avant de fabriquer l'objet
			// 1 = Oui, 2 = Non
			fmt.Println("1 - Oui je suis sÃ»r !")
			fmt.Println("2 - Non je ne suis pas sÃ»r, retour !")
			fmt.Scan(&craft_confirmation)
			switch craft_confirmation {
			case 1:
				// Fabrication du chapeau
				fmt.Println("\nTu viens de fabriquer", itemcraftable, "x Chapeau de l'Aventurier")
				// Retrait des matÃ©riaux de l'inventaire
				inventory.RemoveInventory(c, ravenFeather)
				inventory.RemoveInventory(c, boarLeather)
				// Ajout du chapeau Ã  l'inventaire
				inventory.AddInventory(c, chapeauAventurier)
			case 2:
				// Retour au menu prÃ©cÃ©dent sans fabriquer l'objet
				fmt.Printf("\nRetour au menu prÃ©cÃ©dent\n")
			}

		case 2:
			// Fabrication de la Tunique de l'aventurier
			//besoin de 2 fourrures de loup + 1 peau de troll
			itemcraftable := min(countWolfFur/2, countTrollSkin)
			if itemcraftable < 1 {
				fmt.Printf("\nâŒ Tu n'as pas les objets requis pour Tunique de l'aventurier de l'Aventurier\n\n")
				break
			} else {
				fmt.Printf("\nTu peux fabriquer %dx Chapeau de l'Aventurier, veux-tu en fabriquer 1 ?\n", itemcraftable)
			}

			fmt.Println("1 - Oui je suis sÃ»r !")
			fmt.Println("2 - Non je ne suis pas sÃ»r, retour !")
			fmt.Scan(&craft_confirmation)
			switch craft_confirmation {
			case 1:
				// Fabrication de la tunique, retrait des matÃ©riaux et ajout Ã  l'inventaire
				fmt.Printf("\nTu viens de fabriquer %d x Tunique de l'Aventurier\n\n", itemcraftable)
				inventory.RemoveInventory(c, wolfFur)
				inventory.RemoveInventory(c, wolfFur) //Retire 2 fourrures de loup
				inventory.RemoveInventory(c, trollSkin)
				inventory.AddInventory(c, tuniqueAventurier)
			case 2:
				// Retour au menu prÃ©cÃ©dent sans fabriquer l'objet
				fmt.Printf("\nRetour au menu prÃ©cÃ©dent\n\n")
			}

		case 3:
			// Fabrication des Bottes de l'aventurier
			itemcraftable := min(countWolfFur, countBoarLeather)
			if itemcraftable < 1 {
				fmt.Printf("\nâŒ Tu n'as pas les objets requis pour Bottes de l'aventurier de l'Aventurier\n\n")
				break
			} else {
				fmt.Printf("\nTu peux fabriquer %dx Chapeau de l'Aventurier, veux-tu en fabriquer 1 ?\n", itemcraftable)
			}

			fmt.Println("1 - Oui je suis sÃ»r !")
			fmt.Println("2 - Non je ne suis pas sÃ»r, retour !")
			fmt.Scan(&craft_confirmation)
			switch craft_confirmation {
			case 1:
				// Fabrication des bottes, retrait des matÃ©riaux et ajout Ã  l'inventaire
				fmt.Printf("\nTu viens de fabriquer %d x Bottes de l'Aventurier\n\n", itemcraftable)
				inventory.RemoveInventory(c, wolfFur)
				inventory.RemoveInventory(c, boarLeather)
				inventory.AddInventory(c, bottesAventurier)
			case 2:
				// Retour au menu prÃ©cÃ©dent sans fabriquer l'objet
				fmt.Printf("\nRetour au menu prÃ©cÃ©dent\n")
			}

		case 4:
			// Retour au menu prÃ©cÃ©dent
		}
		if forgeron_choice == 4 {
			forgeron_choice = 0
			break
		}
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\inventory\inventory.go
package inventory

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/structures"
)

// AddInventory ajoute un objet Ã  l'inventaire du personnage, en augmentant la quantitÃ© si l'objet existe dÃ©jÃ 
func AddInventory(c *structures.Character, newObj structures.Object) {
	for i := range c.Inventory {
		if c.Inventory[i].Name == newObj.Name {
			c.Inventory[i].Quantity += newObj.Quantity
			return
		}
	}
	c.Inventory = append(c.Inventory, newObj)
}

// RemoveInventory retire un objet de l'inventaire du personnage, en diminuant la quantitÃ©
// ou en supprimant l'objet si la quantitÃ© atteint zÃ©ro
func RemoveInventory(c *structures.Character, obj structures.Object) {
	for i := range c.Inventory {
		if c.Inventory[i].Name == obj.Name {
			if c.Inventory[i].Quantity > obj.Quantity {
				c.Inventory[i].Quantity -= obj.Quantity
			} else {
				c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
			}
			return
		}
	}
}

// AddEquipment Ã©quipe un objet d'armure au personnage, en remplaÃ§ant l'armure existante si nÃ©cessaire
func AddEquipment(c *structures.Character, newObj structures.Object) {
	// Ã‰quipe l'armure en fonction de son type (tÃªte, torse, jambes)
	switch newObj.Name {
	case "Chapeau de l'aventurier":
		// VÃ©rifie si l'armure de tÃªte est dÃ©jÃ  Ã©quipÃ©e
		if c.Armor.Head.Name != "Chapeau de l'aventurier" {
			// Si l'armure de tÃªte n'est pas Ã©quipÃ©e, l'Ã©quipe
			c.Armor.Head = &newObj
			fmt.Printf("\nTu Ã©quipes : Chapeau de l'aventurier\n\n")
			fmt.Printf("\nTu gagnes + 10 PV Max\n\n")
			fmt.Printf("%d/%d PV -> %d/%d PV\n\n", c.ActualHp, c.MaxHp, c.ActualHp, c.MaxHp+10)
			// Augmente les PV max du personnage de 10
			c.MaxHp += 10
			// Retire l'objet de l'inventaire
			RemoveInventory(c, newObj)
		} else {
			// Si l'armure de tÃªte est dÃ©jÃ  Ã©quipÃ©e, affiche un message et ne fait rien
			fmt.Printf("\nâŒ Tu as dÃ©jÃ  Ã©quipÃ© : %s\n\n", newObj.Name)
		}
	case "Tunique de l'aventurier":
		// VÃ©rifie si l'armure de torse est dÃ©jÃ  Ã©quipÃ©e, si ce n'est pas le cas, l'Ã©quipe
		// et augmente les PV max de 25
		if c.Armor.Chest.Name != "Tunique de l'aventurier" {
			c.Armor.Chest = &newObj
			fmt.Printf("\nTu Ã©quipes : Tunique de l'aventurier\n\n")
			fmt.Printf("\nTu gagnes + 25 PV Max\n\n")
			fmt.Printf("%d/%d PV -> %d/%d PV\n\n", c.ActualHp, c.MaxHp, c.ActualHp, c.MaxHp+25)
			c.MaxHp += 25
			RemoveInventory(c, newObj)
		} else {
			fmt.Printf("\nâŒ Tu as dÃ©jÃ  Ã©quipÃ© : %s\n\n", newObj.Name)
		}
	case "Bottes de l'aventurier":
		// VÃ©rifie si l'armure de jambes est dÃ©jÃ  Ã©quipÃ©e, si ce n'est pas le cas, l'Ã©quipe
		// et augmente les PV max de 15
		if c.Armor.Legs.Name != "Bottes de l'aventurier" {
			c.Armor.Legs = &newObj
			fmt.Printf("\nTu Ã©quipes : Bottes de l'aventurier\n\n")
			fmt.Printf("\nTu gagnes + 15 PV Max\n\n")
			fmt.Printf("%d/%d PV -> %d/%d PV\n\n", c.ActualHp, c.MaxHp, c.ActualHp, c.MaxHp+15)
			c.MaxHp += 15
			RemoveInventory(c, newObj)
		} else {
			fmt.Printf("\nâŒ Tu as dÃ©jÃ  Ã©quipÃ© : %s\n\n", newObj.Name)
		}
	}
}

// Fonction pour ajouter de l'argent au personnage en fonction de la difficultÃ© de l'ennemi vaincu
func AddMoney(c *structures.Character, e *structures.Enemy) {
	c.Money += e.GiveMoney
}

// CheckMaxInventory vÃ©rifie si l'inventaire du personnage a de la place pour ajouter de nouveaux objets
// True = Il y a de la place, False = Inventaire plein
func CheckMaxInventory(c *structures.Character) bool {
	counter := 0
	for i := range c.Inventory {
		counter = counter + c.Inventory[i].Quantity
	}
	return counter < c.MaxInv
}

// UpgradeInventorySlot augmente la capacitÃ© maximale de l'inventaire du personnage de 10 emplacements
func UpgradeInventorySlot(c *structures.Character) {
	c.MaxInv = c.MaxInv + 10
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\items\items.go
package items

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/structures"
)

// Fonction pour utiliser une potion de vie
func TakePot(c *structures.Character) {
	// DÃ©finir le nom de la potion de vie
	HpPot := structures.Object{Name: "Potion de Vie"}
	// VÃ©rifier si le personnage a dÃ©jÃ  les PV max
	if c.ActualHp == c.MaxHp {
		fmt.Printf("\nLes points de vie sont dÃ©jÃ  au max\n\n")
		// Ne rien faire
		return
	}
	// Parcourir l'inventaire du personnage pour trouver la potion de vie
	for i := 0; i < len(c.Inventory); i++ {
		// Si la potion de vie est trouvÃ©e
		if c.Inventory[i].Name == HpPot.Name {
			// Augmenter les PV actuels du personnage de 50
			c.ActualHp += 50
			// RÃ©duire la quantitÃ© de la potion de vie dans l'inventaire
			c.Inventory[i].Quantity--
			// Si la quantitÃ© de la potion de vie est Ã©gale Ã  0, la retirer de l'inventaire
			if c.Inventory[i].Quantity == 0 {
				c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
			}
			// Si les PV actuels dÃ©passent les PV max, les ramener aux PV max
			if c.ActualHp >= c.MaxHp {
				c.ActualHp = c.MaxHp
			}
			// Afficher un message indiquant que la potion a Ã©tÃ© consommÃ©e et les PV actuels
			fmt.Printf("\nPotion consommÃ©e ! +50 PV\n")
			fmt.Printf("PV actuels: %d\n", c.ActualHp)
			// Sortir de la fonction
			return
		}
	}
	// Si la potion de vie n'est pas trouvÃ©e dans l'inventaire, afficher un message d'erreur
	fmt.Println("âŒ Il n'y a pas de potions de Vie dans l'inventaire")
}

func CheckPoisonStatus(e *structures.Enemy) {
	if e.Poisoned && e.PoisonTurns > 0 {
		e.ActualHp -= e.PoisonDamage
		fmt.Printf("â˜ ï¸ %s subit %d dÃ©gÃ¢ts de poison (%d tours restants)\n", e.Name, e.PoisonDamage, e.PoisonTurns)
		e.PoisonTurns--

		if e.PoisonTurns == 0 {
			e.Poisoned = false
			fmt.Println("âœ… Le poison sâ€™est dissipÃ©.")
		}
	}

}

// Fonction pour utiliser une potion de mana
// A FINIR
func TakeManaPot(c *structures.Character) {
	ManaPot := structures.Object{Name: "Potion de Mana"}
	if c.ActualMana == c.ManaMax {
		fmt.Printf("\nLes points de vie sont dÃ©jÃ  au max\n\n")
		return
	}
	for i := 0; i < len(c.Inventory); i++ {
		if c.Inventory[i].Name == ManaPot.Name {
			c.ActualHp += 20
			c.Inventory[i].Quantity--
			if c.Inventory[i].Quantity == 0 {
				c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
			}
			if c.ActualMana >= c.ManaMax {
				c.ActualMana = c.ManaMax
			}
			fmt.Printf("\nPotion consommÃ©e !\n")
			fmt.Printf("Mana actuel: %d\n", c.ActualMana)

			return
		}
	}
	fmt.Println("âŒIl n'y a pas de potions de Mana dans l'inventaire")
}

// Fonction pour utiliser une potion de poison
// A FINIR (effet sur plusieurs tours)
func ThrowPoisonPot(c *structures.Character, e *structures.Enemy) {
	// DÃ©finir le nom de la potion de poison
	PoisonPot := structures.Object{Name: "Potion de Poison"}
	// Parcourir l'inventaire du personnage pour trouver la potion de poison, si trouvÃ©e l'utiliser, la retirer
	// et infliger des dÃ©gÃ¢ts sur plusieurs tours Ã  l'ennemi
	for i := 0; i < len(c.Inventory); i++ {
		if c.Inventory[i].Name == PoisonPot.Name {
			if c.Inventory[i].Quantity == 0 {
				c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
				e.ActualHp -= 10
				c.Inventory[i].Quantity--
			}
			// Effet de la potion de poison sur 3 tours (10 dÃ©gÃ¢ts par tour)
			//A FINIR (ajouter un effet de poison sur plusieurs tours)
			fmt.Printf("\nPotion envoyÃ©e !\n")

			// Appliquer lâ€™effet poison
			e.Poisoned = true
			e.PoisonTurns = 3   // dure 3 tours
			e.PoisonDamage = 10 // 10 dÃ©gÃ¢ts par tour

			fmt.Println("\nğŸ’€ L'ennemi est empoisonnÃ© pour 3 tours !")
			return
		}
	}
	fmt.Println("âŒ Il n'y a pas de potion de poison dans l'inventaire.")
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\main.go
package main

import (
	"fmt"
	"os"
	"projet-red_PIZZA-BATTLE/affichage"
	"projet-red_PIZZA-BATTLE/character"
	"projet-red_PIZZA-BATTLE/combat"
	"projet-red_PIZZA-BATTLE/forgeron"
	"projet-red_PIZZA-BATTLE/marchand"
	"projet-red_PIZZA-BATTLE/structures"
)

// main est le point d'entrÃ©e du programme
func main() {
	// Initialisation du choix du menu
	var menuChoice int

	// Boucle principale du jeu
	for {
		// Affichage du menu de dÃ©marrage
		affichage.AffichageMenuDemarrage()
		fmt.Scan(&menuChoice)
		switch menuChoice {
		case 1:
			// On lance une nouvelle partie

			// Initialisation des statistiques, de l'inventaire et des compÃ©tance de l'ennemi
			c1 := structures.InitCharacter()

			// CrÃ©ation du personnage par l'utilisateur
			character.CharacterCreation(c1)

			// Initialisation de l'ennemi
			e1 := structures.InitEnemy("Petit Giovanni", "Facile")

			// Boucle du menu principal
			for {
				affichage.AffichageMenuPrincipal()
				fmt.Scan(&menuChoice)

				switch menuChoice {
				case 1:
					// Afficher les infos du personnage
					character.DisplayCInfo(c1)
				case 2:
					// Menu Inventaire
					character.InventoryChoice(c1)
				case 3:
					// Combat en 1 contre 1
					combat.TurnCombat1v1(c1, e1)
				case 4:
					// Marchand
					marchand.Marchand(c1)
				case 5:
					// Forgeron
					forgeron.Forgeron(c1)
				case 6:
				default:
					// Choix invalide
					fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
				}
				// Reset de la variable menuChoice pour Ã©viter les boucles infinies
				if menuChoice == 6 {
					menuChoice = 0
					// Retour au menu prÃ©cÃ©dent (menu de dÃ©marrage)
					break
				}

			}
		case 2:
			// Quitter le jeu
			os.Exit(0)
		default:
			// Choix invalide
			fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
		}
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\marchand\marchand.go
package marchand

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/affichage"
	"projet-red_PIZZA-BATTLE/character"
	"projet-red_PIZZA-BATTLE/inventory"
	"projet-red_PIZZA-BATTLE/skills"
	"projet-red_PIZZA-BATTLE/structures"
)

// Marchand permet au joueur d'acheter des objets et compÃ©tences s'il a assez d'argent
func Marchand(c *structures.Character) {
	//Initialisation des objets et compÃ©tences vendus par le marchand
	var marchand_choice int

	//Objets
	HpPot := structures.Object{Name: "Potion de Vie", Quantity: 1}
	ManaPot := structures.Object{Name: "Potion de Vie", Quantity: 1}
	PoisonPot := structures.Object{Name: "Potion de Poison", Quantity: 1}
	WolfFur := structures.Object{Name: "Peau de Loup", Quantity: 1}
	TrollSkin := structures.Object{Name: "Peau de Troll", Quantity: 1}
	BoarLeather := structures.Object{Name: "Cuir de Sanglier", Quantity: 1}
	RavenFeather := structures.Object{Name: "Plume de Corbeau", Quantity: 1}

	//CompÃ©tences
	FireBall := structures.Skill{Name: "Boule de feu", Damage: 20, ManaCost: 20}
	DeathSpell := structures.Skill{Name: "Sort de la mort qui tue", Damage: 500}

	//Boucle principale du marchand
	for {
		//Menu du marchand
		affichage.Separator()
		fmt.Println("ğŸ›’ Bienvenue chez le Marchand !")
		affichage.Separator()
		fmt.Println("Que veux-tu acheter ?")
		fmt.Printf("1 - ğŸ§ª %s - 3ğŸ’°\n", HpPot.Name)
		fmt.Printf("2 - â˜ ï¸  %s - 6ğŸ’°\n", PoisonPot.Name)
		fmt.Printf("3 - ğŸ”® %s - 4ğŸ’°\n", ManaPot.Name)
		fmt.Printf("4 - ğŸ“– Livre de Sort : %s - 25ğŸ’°\n", FireBall.Name)
		fmt.Printf("5 - ğŸº %s - 4ğŸ’°\n", WolfFur.Name)
		fmt.Printf("6 - ğŸ‘¹ %s - 7ğŸ’°\n", TrollSkin.Name)
		fmt.Printf("7 - ğŸ— %s - 3ğŸ’°\n", BoarLeather.Name)
		fmt.Printf("8 - ğŸª¶ %s - 1ğŸ’°\n", RavenFeather.Name)
		fmt.Printf("9 - ğŸ“¦ Agrandir inventaire (+10 emplacements) - 30ğŸ’°\n")
		fmt.Println("10 - â¬…ï¸ Retour")
		// Test
		fmt.Printf("11 - ğŸ“– Livre de Sort : %s - 50ğŸ’° (test)\n", DeathSpell.Name)
		// Fin test

		affichage.Separator()
		fmt.Print("ğŸ‘‰ Ton choix : ")
		fmt.Scan(&marchand_choice)
		switch marchand_choice {
		case 1:
			// Achat d'une potion de vie
			// VÃ©rification de la place dans l'inventaire
			if inventory.CheckMaxInventory(c) {
				// Ajout de l'objet dans l'inventaire
				inventory.AddInventory(c, HpPot)
				// DÃ©duction de l'argent
				c.Money -= 3
				// Message de confirmation
				fmt.Println("âœ… Tu as achetÃ© une Potion de Vie (-3ğŸ’°)")
				// Affichage de l'argent restant
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				// Affichage de l'inventaire
				character.AccessInventory(c)
				// Retour au menu du marchand
			} else {
				// Message d'erreur si l'inventaire est plein
				fmt.Printf("\nâŒ Il n'y a pas assez de place dans l'inventaire\n\n")
				// Affichage de l'inventaire
				character.AccessInventory(c)
				// Retour au menu du marchand
			}
		case 2:
			// Achat d'une potion de poison
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, PoisonPot)
				c.Money -= 6
				fmt.Println("âœ… Tu as achetÃ© une Potion de Poison (-6ğŸ’°)")
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\nâŒ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 3:
			// Achat d'une potion de mana
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, ManaPot)
				c.Money -= 4
				fmt.Println("âœ… Tu as achetÃ© une Potion de Mana (-4ğŸ’°)")
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\nâŒ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 4:
			// Achat d'un livre de sort (compÃ©tence)
			// VÃ©rification si le personnage possÃ¨de dÃ©jÃ  la compÃ©tence
			if !skills.CheckSkills(c, FireBall) {
				// Ajout de la compÃ©tence au personnage
				skills.AddSkills(c, FireBall)
				c.Money -= 25
				fmt.Printf("âœ… Tu as achetÃ© un Livre de Sort : %s (-25ğŸ’°)\n", FireBall.Name)
				// Affichage de la compÃ©tence apprise
				fmt.Printf("ğŸ”¥ Nouvelle compÃ©tence : %s (%d dÃ©gÃ¢ts)\n", FireBall.Name, FireBall.Damage)
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				character.AccessInventory(c)
			} else {
				fmt.Print("\nâŒ Tu possÃ¨des dÃ©jÃ  cette compÃ©tence\n\n")
				character.AccessInventory(c)
			}
		case 5:
			// Achat d'une fourrure de loup
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, WolfFur)
				c.Money -= 4
				fmt.Println("âœ… Tu as achetÃ© une Peau de Loup (-4ğŸ’°)")
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\nâŒ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 6:
			// Achat d'une peau de troll
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, TrollSkin)
				c.Money -= 7
				fmt.Println("âœ… Tu as achetÃ© une Peau de Troll (-7ğŸ’°)")
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\nâŒ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 7:
			// Achat d'un cuir de sanglier
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, BoarLeather)
				c.Money -= 3
				fmt.Println("âœ… Tu as achetÃ© un Cuir de Sanglier (-3ğŸ’°)")
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\nâŒ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 8:
			// Achat d'une plume de corbeau
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, RavenFeather)
				c.Money -= 1
				fmt.Println("âœ… Tu as achetÃ© une Plume de Corbeau (-1ğŸ’°)")
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\nâŒ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}

		case 9:
			// Achat d'une augmentation de l'inventaire
			c.Money -= 30
			fmt.Println("âœ… Ton inventaire s'est agrandi de 10 places (-30ğŸ’°)")
			fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
			// Augmentation de la taille de l'inventaire de 10 slots
			inventory.UpgradeInventorySlot(c)

		case 10:
			// Retour au menu prÃ©cÃ©dent
		case 11:
			// Test achat d'un livre de sort (compÃ©tence)
			if !skills.CheckSkills(c, DeathSpell) {
				skills.AddSkills(c, DeathSpell)
				fmt.Printf("âœ… Tu as achetÃ© un Livre de Sort : %s (-50ğŸ’°)\n", DeathSpell.Name)
				fmt.Printf("ğŸ’€ Nouvelle compÃ©tence : %s (%d dÃ©gÃ¢ts)\n", DeathSpell.Name, DeathSpell.Damage)
				fmt.Println("Tu as maintenant", c.Money, "ğŸ’°")
				character.AccessInventory(c)
			} else {
				fmt.Print("\nâŒ Tu possÃ¨des dÃ©jÃ  cette compÃ©tence\n\n")
				character.AccessInventory(c)
			}
		default:
			// Choix autre que 1 Ã  10
			fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
		}
		// Retour au menu prÃ©cÃ©dent si le choix est 10
		// Reset de la variable marchand_choice si le choix est 10
		// Permet de ne pas rester bloquÃ© dans la boucle du marchand
		if marchand_choice == 10 {
			marchand_choice = 0
			break
		}
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\score\score.go
package score

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/structures"
)

// AddScore ajoute des points au score du personnage en fonction de la difficultÃ© de l'ennemi vaincu
func AddScore(c *structures.Character, e *structures.Enemy) {
	c.Score += e.GiveScore
}

// ShowScore affiche le score actuel du personnage
func ShowScore(c *structures.Character) {
	fmt.Printf("\n\nScore de %s : %d\n\n", c.Name, c.Score)
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\skills\skills.go
package skills

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/structures"
)

// AddSkills ajoute une compÃ©tence Ã  la liste des compÃ©tences du personnage
func AddSkills(c *structures.Character, newSkill structures.Skill) {
	c.SkillList = append(c.SkillList, newSkill)
}

// CheckSkills vÃ©rifie si le personnage a dÃ©jÃ  la compÃ©tence
func CheckSkills(c *structures.Character, newSkill structures.Skill) bool { //True = Il a dÃ©jÃ  la comp.
	for i := range c.SkillList {
		if c.SkillList[i].Name == newSkill.Name {
			return true
		}
	}
	return false
}

// SkillChoice permet au joueur de choisir une compÃ©tence Ã  utiliser et retourne la compÃ©tence choisie
func SkillChoice(c *structures.Character) structures.Skill {
	var skill_choice int
	// Affiche la liste des compÃ©tences disponibles
	for {
		fmt.Println("\nQuelle compÃ©tence veux-tu utiliser ?")
		for i := range c.SkillList {
			fmt.Printf("%d - %s\n", i+1, c.SkillList[i].Name)
		}
		fmt.Print("ğŸ‘‰ Ton choix : ")
		fmt.Scan(&skill_choice)
		// VÃ©rifie que le choix est valide dans la liste des compÃ©tences
		if skill_choice >= 1 && skill_choice <= len(c.SkillList) {
			// Retourne la compÃ©tence choisie (indexÃ©e Ã  partir de 0)
			return c.SkillList[skill_choice-1]
		}
		// Si le choix n'est pas valide, affiche un message d'erreur et redemande
		fmt.Printf("\nâŒ Il ne se passe rien... Choix invalide.\n")
	}
}

// UseSkill applique les effets de la compÃ©tence sur les pv de l'ennemi
func UseSkill(c *structures.Character, e *structures.Enemy, skill structures.Skill) {
	e.ActualHp -= skill.Damage
}

// CheckMana vÃ©rifie si le personnage a assez de mana pour utiliser une compÃ©tence
func CheckMana(c *structures.Character, skill structures.Skill) {
	if c.ActualMana < skill.ManaCost {
		fmt.Println("Vous n'avez pas assez de mana pour lancer ce sort")
	}

}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\structures\structures.go
package structures

// Object reprÃ©sente un objet dans l'inventaire ou l'Ã©quipement
type Object struct {
	Name     string
	Quantity int
}

// Character reprÃ©sente un personnage joueur avec ses attributs et son inventaire
type Character struct {
	Name       string
	Class      string
	Level      int
	MaxHp      int
	ActualHp   int
	Inventory  []Object
	MaxInv     int
	Money      int
	SkillList  []Skill
	Armor      Equipment
	Score      int
	Initiative int
	ActualExp  int
	MaxExp     int
	ActualMana int
	ManaMax    int
}

// Enemy reprÃ©sente un ennemi avec ses attributs
type Enemy struct {
	Name         string
	MaxHp        int
	ActualHp     int
	Damage       int
	Difficulty   string //3 types : Facile= score 5, Normale= score 10, Boss= score 20
	Initiative   int
	PowerCount   int
	GiveScore    int
	GiveMoney    int
	GiveExp      int
	Poisoned     bool
	PoisonTurns  int
	PoisonDamage int
}

// Skill reprÃ©sente une compÃ©tence que le personnage peut utiliser en combat
type Skill struct {
	Name     string
	Damage   int
	ManaCost int
}

// Equipment reprÃ©sente l'Ã©quipement portÃ© par le personnage
type Equipment struct {
	Head  *Object //Pointeur unique vide de structure Objects
	Chest *Object //Un Ã©quipement pour le torse
	Legs  *Object //Un Ã©quipement pour les pieds

}

// InitCharacter initialise un personnage avec des valeurs par dÃ©faut sans nom ni classe (dÃ©finis par CharacterCreation)
func InitCharacter() *Character {
	return &Character{
		Level:      1,
		ActualExp:  0,
		MaxExp:     100,
		Initiative: 100,
		// Initialisation avec 3 potions
		Inventory: []Object{
			{Name: "Potion de Vie", Quantity: 3},
		},
		ActualHp: 100,
		MaxInv:   10,
		Money:    100,
		// Initialisation de la compÃ©tance de base
		SkillList: []Skill{
			{Name: "Coup de poing", Damage: 10, ManaCost: 0},
		},
		// Initialisation de l'armure (rien d'Ã©auipÃ©)
		Armor: Equipment{
			Head:  &Object{Name: ""},
			Chest: &Object{Name: ""},
			Legs:  &Object{Name: ""},
		},
		//Score de fin de partie
		Score: 0,
	}
}

// InitEnemy initialise un Ennemi avec des valeurs donnÃ©e selon la difficultÃ© donnÃ©e et les valeurs donnÃ©es
func InitEnemy(name string, grade string) *Enemy {
	switch grade {
	// si La difficultÃ© donnÃ©e est "Facile"
	case "Facile":

		return &Enemy{
			Name:       name,
			MaxHp:      100,
			ActualHp:   100,
			Damage:     5,
			Difficulty: "Facile",
			Initiative: 100,
			PowerCount: 0,
			GiveScore:  5,
			GiveMoney:  5,
			GiveExp:    100,
		}
		// si La difficultÃ© donnÃ©e est "Normale"
	case "Normale":

		return &Enemy{
			Name:       name,
			MaxHp:      120,
			ActualHp:   120,
			Damage:     15,
			Difficulty: "Normal",
			Initiative: 120,
			PowerCount: 0,
			GiveScore:  10,
			GiveMoney:  10,
			GiveExp:    150,
		}
		// si La difficultÃ© donnÃ©e est "Boss"
	case "Boss":

		return &Enemy{
			Name:       name,
			MaxHp:      200,
			ActualHp:   200,
			Damage:     25,
			Difficulty: "Boss",
			Initiative: 150,
			PowerCount: 0,
			GiveScore:  5,
			GiveMoney:  5,
			GiveExp:    300,
		}
	}
	// si La difficultÃ© donnÃ©e est rien, initialise quand mÃªme un ennemi "Facile"
	return &Enemy{
		Name:       name,
		MaxHp:      100,
		ActualHp:   100,
		Damage:     5,
		Difficulty: "Facile",
		Initiative: 100,
		PowerCount: 0,
		GiveScore:  5,
		GiveMoney:  5,
		GiveExp:    100,
	}
}

//Initialise une compÃ©tence utilisable dans la liste des compÃ©tences
func InitSkill(name string, damage int) *Skill {
	return &Skill{
		Name:   name,
		Damage: damage,
	}

}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\test.go
package main

import (
	"fmt"
	"math/rand"
)

var choix int

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func rollDice() int {
	return rand.Intn(100) + 1
}

func main() {

	fmt.Println("ğŸŸ©â¬œğŸŸ¥ Ã‰preuve de la Mamma : choisissez un nombre, celui le plus proche du score de la Mamma commence.")

	// input joueur sÃ©curisÃ©
	for {
		fmt.Print("Entrez votre nombre (1-100) : ")
		_, err := fmt.Scan(&choix)
		if err == nil && choix >= 1 && choix <= 100 {
			break
		}
		fmt.Println("Valeur invalide ! Tapez un nombre entre 1 et 100.")
	}

	// premier lancer
	mamma := rollDice()
	ennemi := rollDice()

	// affichage clair
	fmt.Printf("Ton Chiffre : %d | Chiffre de la Mamma : %d | Chiffre de l'ennemi : %d\n", choix, mamma, ennemi)

	// en cas d'Ã©galitÃ©
	for choix == ennemi {
		fmt.Println("Ã‰galitÃ© â€” relance des dÃ©s !")
		mamma = rollDice()
		ennemi = rollDice()
		fmt.Printf("Chiffre : %d | Chiffre de la Mamma : %d | Chiffre de l'ennemi : %d\n", choix, mamma, ennemi)
	}

	// distances absolues
	distJoueur := abs(choix - mamma)
	distEnnemi := abs(ennemi - mamma)

	// initiative
	if distJoueur < distEnnemi {
		fmt.Printf("âœ… Vous Ãªtes le plus proche du chiffre de la Mamma avec une distance de %d, vous commencez !\n", distJoueur)
		initiative = initiative + distJoueur
		fmt.Printf("Vous avez %d\n", initiative)
	} else {
		fmt.Printf("âŒ L'ennemi le plus proche du chiffre de la Mamma avec une distance de %d, il commence !\n", distEnnemi)
		initiative = initiative - distEnnemi
		fmt.Printf("Vous avez %d\n", initiative)
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\text.go
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	// Chemin spÃ©cifique du projet
	projectPath := "C:\\Users\\harol\\Documents\\Cours\\Projet RED\\projet-red_PIZZA-BATTLE"
	outputFile := "project_files.txt"

	// Store all file contents
	var allContents []string

	// Walk through the directory
	err := filepath.Walk(projectPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories and non-go files
		if info.IsDir() || !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		// Skip the output file itself
		if info.Name() == outputFile {
			return nil
		}

		// Read file content
		content, err := ioutil.ReadFile(path)
		if err != nil {
			fmt.Printf("Error reading file %s: %v\n", path, err)
			return nil // Continue with other files
		}

		// Add file path and content to collection
		fileEntry := fmt.Sprintf("// FILE: %s\n%s", path, string(content))
		allContents = append(allContents, fileEntry)
		fmt.Printf("Added file: %s\n", path)

		return nil
	})

	if err != nil {
		fmt.Printf("Error walking directory: %v\n", err)
		return
	}

	// Join all contents with separator
	joinedContent := strings.Join(allContents, "\n\n///\n\n")

	// Write to output file
	err = ioutil.WriteFile(outputFile, []byte(joinedContent), 0644)
	if err != nil {
		fmt.Printf("Error writing to output file: %v\n", err)
		return
	}

	fmt.Printf("\nSuccess! All Go files from %s combined into %s\n", projectPath, outputFile)
}
