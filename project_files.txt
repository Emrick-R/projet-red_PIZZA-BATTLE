// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\affichage\affichage.go
package affichage

import "fmt"

// Separator affiche une série de =
func Separator() {
	fmt.Println("==================================================")
}

// AffichageMenuDemarrage affiche le menu de démarrage
func AffichageMenuDemarrage() {
	Separator()
	fmt.Println("🍕 BIENVENUE DANS PIZZA BATTLE 🍕")
	Separator()
	fmt.Println("1 - Commencer une nouvelle partie")
	fmt.Println("2 - Quitter")
	Separator()
}

// AffichageMenuPrincipal affiche le menu principal
func AffichageMenuPrincipal() {
	Separator()
	fmt.Println("👤 Menu Principal :")
	Separator()
	fmt.Println("1 - Afficher le personnage")
	fmt.Println("2 - Inventaire")
	fmt.Println("3 - Combat en 1 contre 1")
	fmt.Println("4 - Marchand")
	fmt.Println("5 - Forgeron")
	fmt.Println("6 - RETOUR")
	Separator()
}

//AffichageMenuInventaire affiche le menu de l'inventaire
func AffichageMenuInventaire() {
	Separator()
	fmt.Println("🎒 Inventaire :")
	Separator()
	fmt.Println("1 - Utiliser une potion")
	fmt.Println("2 - Equiper un équipement")
	fmt.Println("3 - RETOUR")
	Separator()
}

//AffichageMenuCombatPotion affiche le menu des potions uniquement lors des combats
func AffichageMenuCombatPotion() {
	Separator()
	fmt.Println("🧪 Utiliser une potion :")
	Separator()
	fmt.Println("1 - Potion de soin")
	fmt.Println("2 - Potion de poison")
	fmt.Println("3 - RETOUR")
	Separator()
}

//CharacterTurn affiche le menu lors du tour du joueur dans un combat
func CharacterTurn() {
	Separator()
	fmt.Println("⚔️  Combat :")
	Separator()
	fmt.Println("1 - Attaquer")
	fmt.Println("2 - Inventaire")
	fmt.Println("3 - RETOUR")
	Separator()
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\character\character.go
package character

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/affichage"
	"projet-red_PIZZA-BATTLE/inventory"
	"projet-red_PIZZA-BATTLE/items"
	"projet-red_PIZZA-BATTLE/structures"
)

// DisplayCInfo affiche les informations du personnage (nom, classe, PV, niveau, expérience, argent, initiative, score)
func DisplayCInfo(c *structures.Character) {
	affichage.Separator()
	fmt.Println("👤 Informations du personnage :")
	affichage.Separator()
	fmt.Printf("📛 Nom : %s\n", c.Name)
	fmt.Printf("🏹 Classe : %s\n", c.Class)
	fmt.Printf("❤️ PV : %d/%d\n", c.ActualHp, c.MaxHp)
	fmt.Printf("🔵 Mana : %d\n", c.ManaMax)
	fmt.Printf("⭐ Niveau : %d\n", c.Level)
	fmt.Printf("📚 Expérience : %d/%d\n", c.ActualExp, c.MaxExp)
	fmt.Printf("💰 Argent : %d\n", c.Money)
	fmt.Printf("⚡ Initiative : %d\n", c.Initiative)
	fmt.Printf("🏆 Score : %d\n", c.Score)
	affichage.Separator()
}

// DisplayEInfo affiche les informations de l'ennemi (nom, PV, initiative)
func DisplayEInfo(e *structures.Enemy) {
	affichage.Separator()
	fmt.Println("👹 Informations de l'ennemi :")
	affichage.Separator()
	fmt.Printf("📛 Nom : %s\n", e.Name)
	fmt.Printf("❤️ PV : %d/%d\n", e.ActualHp, e.MaxHp)
	fmt.Printf("⚡ Initiative : %d\n", e.Initiative)
	affichage.Separator()
}

// AccessInventory affiche le contenu de l'inventaire du personnage (nom et quantité des objets)
func AccessInventory(c *structures.Character) {
	affichage.Separator()
	fmt.Println("🎒 Inventaire :")
	affichage.Separator()
	for i := range c.Inventory {
		fmt.Printf("- %s (x%d)\n", c.Inventory[i].Name, c.Inventory[i].Quantity)
	}
}

// AccessSkills affiche la liste des compétences du personnage (nom et dégâts)
func AccessSkills(c *structures.Character) {
	affichage.Separator()
	fmt.Println("📜 Compétences :")
	affichage.Separator()
	for s := range c.SkillList {
		fmt.Printf("- %s : %d points de dégâts\n", c.SkillList[s].Name, c.SkillList[s].Damage)
	}
	fmt.Println()
}

// AccessEquipement affiche l'équipement porté par le personnage (nom de l'armure de tête, torse et jambes)
func AccessEquipement(c *structures.Character) {
	affichage.Separator()
	fmt.Println("🛡️  Équipement :")
	affichage.Separator()
	H := c.Armor.Head.Name
	C := c.Armor.Chest.Name
	L := c.Armor.Legs.Name
	if H == "" {
		H = "Rien"
	}
	if C == "" {
		C = "Rien"
	}
	if L == "" {
		L = "Rien"
	}

	fmt.Println("👒 Armure de tête : ", H)
	fmt.Println("👕 Armure de torse : ", C)
	fmt.Println("👖 Armure de jambes : ", L)

}

// InventoryChoice affiche l'inventaire, les equipements equipés, la liste des compétences et
// permet au joueur de choisir une action (utiliser une potion, équiper un équipement, ou revenir en arrière)
func InventoryChoice(c *structures.Character) {
	for {
		AccessInventory(c)
		AccessEquipement(c)
		AccessSkills(c)
		affichage.AffichageMenuInventaire()
		menuChoice := 0
		fmt.Print("👉 Ton choix : ")
		fmt.Scan(&menuChoice)
		switch menuChoice {
		case 1:
			// Utiliser une potion
			items.TakePot(c)
		case 2:
			// Equiper un équipement
			EquipEquipment(c)
		case 3:
		// Retour
		default:
			fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
		}
		if menuChoice == 3 {
			menuChoice = 0
			return
		}
	}
}

// EquipEquipment permet au joueur d'équiper un équipement (chapeau, tunique, bottes)
// s'il le possède dans son inventaire
func EquipEquipment(c *structures.Character) {
	//Itinialisation des équipements disponibles
	var newEquipChoice int
	chapAvent := structures.Object{Name: "Chapeau de l'aventurier", Quantity: 1}
	tunAvent := structures.Object{Name: "Tunique de l'aventurier", Quantity: 1}
	botAvent := structures.Object{Name: "Bottes de l'aventurier", Quantity: 1}
	for {
		// Affichage du menu d'équipement
		affichage.Separator()
		fmt.Println("🛡️  Choisis ton équipement :")
		affichage.Separator()
		fmt.Println("1 - 👒 Chapeau de l'aventurier")
		fmt.Println("2 - 👕 Tunique de l'aventurier")
		fmt.Println("3 - 👢 Bottes de l'aventurier")
		fmt.Println("4 - ⬅️ RETOUR")
		affichage.Separator()

		fmt.Print("👉 Ton choix : ")
		fmt.Scan(&newEquipChoice)
		// Vérification si le joueur possède l'équipement dans son inventaire
		// Iniatialisation des booléens pour savoir si le joueur possède l'équipement
		hadChap := false
		hadTun := false
		hadBot := false
		// Parcours de l'inventaire pour vérifier la présence des équipements
		// et mise à jour des booléens en conséquence
		// Si le joueur possède l'équipement, il peut l'équiper
		for _, i := range c.Inventory {
			if i.Name == chapAvent.Name {
				hadChap = true
			}
			if i.Name == tunAvent.Name {
				hadTun = true
			}
			if i.Name == botAvent.Name {
				hadBot = true
			}
		}

		// Équipement de l'objet choisi si le joueur le possède
		// Sinon, affichage d'un message d'erreur
		// Retour au menu précédent si le choix est 4
		switch newEquipChoice {
		case 1:
			// Équiper le chapeau de l'aventurier
			if hadChap {
				// Ajout de l'équipement à l'inventaire du personnage
				inventory.AddEquipment(c, chapAvent)
			} else {
				// Message d'erreur si le joueur ne possède pas l'équipement
				fmt.Printf("\n❌ Tu ne possèdes pas : %s\n\n", chapAvent.Name)
			}
		case 2:
			// Équiper la tunique de l'aventurier
			if hadTun {
				inventory.AddEquipment(c, tunAvent)
			} else {
				fmt.Printf("\n❌ Tu ne possèdes pas : %s\n\n", tunAvent.Name)
			}
		case 3:
			// Équiper les bottes de l'aventurier
			if hadBot {
				inventory.AddEquipment(c, botAvent)
			} else {
				fmt.Printf("\n❌Tu ne possèdes pas : %s\n\n", botAvent.Name)
			}
		case 4:

		default:
			fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
		}
		if newEquipChoice == 4 {
			newEquipChoice = 0
			break
		}
	}
}

// CharacterCreation permet de créer un personnage en choisissant un pseudo et une classe
func CharacterCreation(c *structures.Character) {
	// Initialisation des variables
	var username string
	var valid bool

	// Boucle pour demander un pseudo valide
	for {
		affichage.Separator()
		fmt.Println("✏️  Création du personnage")
		affichage.Separator()
		fmt.Print("👉 Quel est ton pseudo ? ")
		fmt.Scan(&username)
		valid = true
		result := []rune(username)

		// Vérification que le pseudo n'est pas vide et ne contient que des lettres
		if len(result) == 0 {
			fmt.Println("❌ Le pseudo ne peut pas être vide.")
			valid = false
			continue
		}

		// Vérification que chaque caractère est une lettre
		for _, r := range result {
			if r < 65 || (r > 90 && r < 97) || r > 122 {
				fmt.Println("❌ Le pseudo ne doit contenir que des lettres.")
				valid = false
				break
			}
		}

		// Si le pseudo est valide, on le formate (première lettre majuscule, le reste en minuscule)
		if valid {
			if result[0] >= 97 && result[0] <= 122 {
				result[0] = result[0] - ('a' - 'A')
			}
			for i := 1; i < len(result); i++ {
				if result[i] >= 65 && result[i] <= 90 {
					result[i] = result[i] + ('a' - 'A')
				}
			}

			// Assignation du pseudo au personnage
			username = string(result)
			c.Name = username
			// Sortie de la boucle
			break
		}
	}

	// Choix de la classe du personnage
	fmt.Println("\nPersonnage créé avec le nom :", c.Name)
	// Initialisation de la variable
	var class_choice int
	// Boucle pour demander un choix de classe valide
	for {
		affichage.Separator()
		fmt.Printf("🎭 %s, quelle classe veux-tu choisir ?\n", c.Name)
		affichage.Separator()
		fmt.Println("1 - 🏹 Elfe : 80 PV Max")
		fmt.Println("2 - ⛏️ Nain : 120 PV Max")
		fmt.Println("3 - 🧑 Humain : 100 PV Max")
		affichage.Separator()

		fmt.Print("👉 Ton choix : ")
		fmt.Scan(&class_choice)

		// Vérification que le choix est valide
		if class_choice >= 1 && class_choice <= 3 {
			// Choix valide, on sort de la boucle
			break
		}
		fmt.Println("❌ Choix invalide, essaye encore.")
	}

	// Assignation des caractéristiques en fonction de la classe choisie
	switch class_choice {
	case 1:
		// Classe Elfe (80 PV Max, 40 PV Actuels (on commence avec la moitier des PV max), 120 Mana Max)
		fmt.Println("🌿 Tu as choisi la classe Elfe : agile, précis et en communion avec la nature.")
		c.MaxHp = 80
		c.ActualHp = 40
		c.ManaMax = 120
		c.ActualMana = 120
		c.Class = "Elfe"
	case 2:
		// Classe Nain (120 PV Max, 60 PV Actuels, 80 Mana Max)
		fmt.Println("🪓 Tu as choisi la classe Nain : robuste, courageux et maître de la forge.")
		c.MaxHp = 120
		c.ActualHp = 60
		c.ManaMax = 80
		c.ActualMana = 80
		c.Class = "Nain"
	case 3:
		// Classe Humain (100 PV Max, 50 PV Actuels, 80 Mana Max)
		fmt.Println("⚔️  Tu as choisi la classe Humain : polyvalent, ingénieux et déterminé.")
		c.MaxHp = 100
		c.ActualHp = 50
		c.ManaMax = 80
		c.ActualMana = 80
		c.Class = "Humain"
	}
}

// Fonction pour ajouter de l'experience au personnage en fonction de la difficulté de l'ennemi vaincu
func AddExp(c *structures.Character, e *structures.Enemy) {
	c.ActualExp += e.GiveExp
}

func NextLevel(c *structures.Character) {
	for c.ActualExp >= c.MaxExp {
		// Déduction de l'XP du niveau en cours
		c.ActualExp -= c.MaxExp

		// Monter de niveau
		c.Level++

		// Augmenter les stats
		c.MaxExp = int(float64(c.MaxExp) * 1.25)
		c.ManaMax = c.ManaMax + 20
		c.MaxHp = c.MaxHp + 20
		c.Initiative = int(float64(c.MaxHp) * 1.1)
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\combat\combat.go
package combat

import (
	"fmt"
	"math/rand"
	"os"
	"projet-red_PIZZA-BATTLE/affichage"
	"projet-red_PIZZA-BATTLE/character"
	"projet-red_PIZZA-BATTLE/inventory"
	"projet-red_PIZZA-BATTLE/items"
	"projet-red_PIZZA-BATTLE/score"
	"projet-red_PIZZA-BATTLE/skills"
	"projet-red_PIZZA-BATTLE/structures"
	"time"
)

// Fonction valeur absolue
func abs(x int) int {
	// Si x est négatif
	if x < 0 {
		// On retourne son opposé
		return -x
	}
	// Sinon on retourne x
	return x
}

// Fonction pour lancer un dé à 100 faces
func rollDice() int {
	// Génère et retourne un nombre aléatoire entre 1 et 100
	return rand.Intn(100) + 1
}

// Fonction pour déterminer l'initiative en utilisant le mini-jeu "Épreuve de la Mamma"
// Si le joueur gagne, il commence, sinon l'ennemi commence
func InitiativeMamma(c *structures.Character, e *structures.Enemy) bool {

	// Variable du choix du joueur
	var choix int
	affichage.Separator()
	fmt.Println("🟩⬜🟥 Épreuve de la Mamma 🟩⬜🟥")
	affichage.Separator()
	fmt.Println("Choisissez un nombre (1 à 100). Celui le plus proche du score de la Mamma commence !")
	// input joueur sécurisé
	for {
		fmt.Print("👉 Entres ton nombre : ")
		_, err := fmt.Scan(&choix)
		// vérification de l'input
		if err == nil && choix >= 1 && choix <= 100 {
			// input valide, on sort de la boucle
			break
		}
		fmt.Println("❌ Valeur invalide ! Tapes un nombre entre 1 et 100.")
	}

	// premier lancer
	mamma := rollDice()
	ennemi := rollDice()

	// affichage clair
	fmt.Printf("🎲 Ton nombre : %d | 🎲 Mamma : %d | 🎲 Ennemi : %d\n", choix, mamma, ennemi)

	// en cas d'égalité on relance les dés
	for choix == ennemi {
		fmt.Println("Égalité — relance du nombre !")
		mamma = rollDice()
		ennemi = rollDice()
		fmt.Printf("🎲 Chiffre : %d | 🎲 Mamma : %d | 🎲 Ennemi : %d\n", choix, mamma, ennemi)
	}

	// distances absolues (Rappel: la distance est petite == Gagnant)
	distJoueur := abs(choix + c.Initiative - mamma)
	distEnnemi := abs(ennemi + e.Initiative - mamma)

	// affichage du résultat

	if distJoueur < distEnnemi {
		// Joueur gagne
		fmt.Printf("✅ Tu est le plus proche du chiffre de la Mamma avec une distance de %d (Initiative de %d contre %d), vous commencez !\n", distJoueur, c.Initiative, e.Initiative)
		return true
	} else {
		// Ennemi gagne
		fmt.Printf("❌ L'ennemi est plus proche du chiffre de la Mamma avec une distance de %d (Initiative de %d contre %d), il commence !\n", distEnnemi, e.Initiative, c.Initiative)
		return false
	}
}

// Affichage de l'inventaire disponible uniquement en combat
func DisplayCombatInventory(c *structures.Character, e *structures.Enemy) {
	// Boucle infinie jusqu'au retour
	for {
		// Affichage de l'inventaire via une fonction
		character.AccessInventory(c)

		// Affichage de l'équipement
		character.AccessEquipement(c)

		// Affichage des compétences
		character.AccessSkills(c)

		// Affichage des choix
		affichage.AffichageMenuInventaire()
		menuChoice := 0
		fmt.Print("👉 Ton choix : ")
		fmt.Scan(&menuChoice)
		switch menuChoice {
		case 1:
			// Choix 1 : Utiliser une potion
			for {
				affichage.AffichageMenuCombatPotion()
				menuChoice := 0
				fmt.Print("👉 Ton choix : ")
				fmt.Scan(&menuChoice)
				switch menuChoice {
				case 1:
					// Utiliser une potion de vie
					items.TakePot(c)
					return
				case 2:
					//Utiliser une potion de poison
					items.ThrowPoisonPot(c, e)
					return
				case 3:
				//Retour
				default:
					// Choix autre que 1, 2 ou 3
					fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
				}

				if menuChoice == 3 {
					//Reset de la variable menuChoice si choix 3
					menuChoice = 0
					//on retourne au menu inventaire
					break
				}
			}
		case 2:
			// Equiper un équipement
			character.EquipEquipment(c)
		case 3:
			//Retour
		default:
			// Choix autre que 1, 2 ou 3
			fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
		}

		if menuChoice == 3 {
			//Reset de la variable menuChoice si choix 3
			menuChoice = 0
			//on retourne au menu inventaire
			break
		}
	}
}

// Vérification de la mort du personnage avec résurrection (MaxHp/2), si mort définitive (MaxHp <= 10) fin de partie
func CharacterIsDead(c *structures.Character) {
	//Vérification si impossibilité de renaître (MaxHp <= 10)
	if c.MaxHp <= 10 {
		fmt.Println("\n💀 Tu es mort pour de bon !")
		fmt.Println("Impossibilité de renaître...")
		fmt.Println("======== Fin de partie ========")
		//Affichage du score final
		score.ShowScore(c)
		//Pause de 7 secondes avant fermeture du programme
		time.Sleep(7 * time.Second)
		os.Exit(0)
	}

	//Vérification de la mort du personnage puis résurrection avec moitié des PV max
	if c.ActualHp <= 0 {
		fmt.Println("\n💀 Tu es mort !")
		//Résurrection avec moitié des PV max
		c.MaxHp /= 2
		c.ActualHp = c.MaxHp
		fmt.Println("✨ Résurrection avec 50% de HP en moins.")
		fmt.Printf("❤️ PV actuels: %d/%d\n", c.ActualHp, c.MaxHp)
	}
}

// Vérification de la mort de l'ennemi, si mort renvoie true
func EnemyIsDead(e *structures.Enemy) bool {
	//Si les PV de l'ennemi sont inférieurs ou égaux à 0
	if e.ActualHp <= 0 {
		fmt.Printf("⚔️  Tu as vaincu %s !\n", e.Name)
		//Ennemi mort donc true
		return true
	}
	//Ennemi toujours en vie donc false
	return false
}

// Comportement de l'ennemi lors de son tour
func EnemyPattern(c *structures.Character, e *structures.Enemy, t int) {
	//Tout les 3 tours l'ennemi fait une attaque spéciale (double dégâts)
	if e.PowerCount == 3 {
		//Tour Spécial
		//Remise à 0 du compteur
		e.PowerCount = 0
		//Dégâts doublés sur ce tour
		p := e.Damage * 2
		fmt.Printf("🔥 %s utilise une ATTAQUE SPÉCIALE sur %s et inflige %d dégâts !\n", e.Name, c.Name, p)
		//Application des dégâts
		c.ActualHp = c.ActualHp - p
		//Affichage des PV restants
		fmt.Printf("❤️ %s : %d/%d HP\n", c.Name, c.ActualHp, c.MaxHp)
	} else {
		//Autre tours
		//Attaque normale
		c.ActualHp = c.ActualHp - e.Damage
		fmt.Printf("👊 %s attaque %s et inflige %d dégâts\n", e.Name, c.Name, e.Damage)
		fmt.Printf("❤️ %s : %d/%d HP\n", c.Name, c.ActualHp, c.MaxHp)
		//Incrémentation du compteur de l'attaque spéciale
		e.PowerCount++
	}
}

// Tour du personnage
func CharacterTurn(c *structures.Character, e *structures.Enemy) {
	for {
		//Boucle infinie jusqu'à un retour (fin du tour)
		var combat_choice int
		//Affichage du menu combat
		affichage.Separator()
		fmt.Println("⚔️  COMBAT :")
		affichage.Separator()
		fmt.Println("1 - 🗡️ Attaquer")
		fmt.Println("2 - 🎒 Inventaire")

		fmt.Print("👉 Ton choix : ")
		fmt.Scan(&combat_choice)
		switch combat_choice {
		case 1:
			// Attaque

			// Choix de la compétence : sors la compétence choisie
			chosenSkill := skills.SkillChoice(c)

			// Vérification du mana
			skills.CheckMana(c, chosenSkill)
			// Déduction du mana
			c.ActualMana -= chosenSkill.ManaCost
			// Affichage du mana restant
			fmt.Printf("🔵 Mana restant : %d/%d\n", c.ActualMana, c.ManaMax)
			// Utilisation de la compétence sur l'ennemi
			skills.UseSkill(c, e, chosenSkill)
			// Affichage des dégâts infligés et des PV restants de l'ennemi
			fmt.Printf("\n💥 %s inflige %d points de dégâts à %s !\n", c.Name, chosenSkill.Damage, e.Name)
			fmt.Printf("❤️ %s : %d/%d HP\n", e.Name, e.ActualHp, e.MaxHp)
			// Fin du tour du joueur
			return
		case 2:
			for {
				// Affichage de l'inventaire

				// Affichage de l'inventaire via une fonction
				character.AccessInventory(c)
				// Affichage de l'équipement
				character.AccessEquipement(c)
				// Affichage des compétences
				character.AccessSkills(c)
				// Affichage des choix
				affichage.AffichageMenuInventaire()
				menuChoice := 0
				fmt.Print("👉 Ton choix : ")
				fmt.Scan(&menuChoice)
				switch menuChoice {
				case 1:
					for {
						// Affichage des choix de potions
						affichage.AffichageMenuCombatPotion()
						menuChoice := 0
						fmt.Print("👉 Ton choix : ")
						fmt.Scan(&menuChoice)
						switch menuChoice {
						case 1:
							// Utiliser une potion
							items.TakePot(c)
							// Fin du tour du joueur
							return
						case 2:
							//Utiliser une potion de poison
							items.ThrowPoisonPot(c, e)
							// Fin du tour du joueur
							return
						case 3:
						//Retour
						default:
							// Choix autre que 1, 2 ou 3
							fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
						}
						//Reset de la variable menuChoice
						if menuChoice == 3 {
							menuChoice = 0
							break
						}
					}
				case 2:
					// Equiper un équipement
					character.EquipEquipment(c)
				case 3:
				// Retour
				default:
					// Choix autre que 1, 2 ou 3
					fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
				}
				//Reset de la variable menuChoice
				if menuChoice == 3 {
					menuChoice = 0
					return
				}
			}
		default:
			// Choix autre que 1 ou 2
			fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
		}

	}
}

// Fonction principale du combat 1v1 entre le personnage et l'ennemi
func TurnCombat1v1(c *structures.Character, e *structures.Enemy) {
	// Initialisation du tour
	Turn := 1
	TrueTurn := 1
	//Initialisation de l'initiative
	if InitiativeMamma(c, e) {
		Turn = 2
	} else {
		Turn = 1
	}
	//Boucle de combat
	for {
		//Le tour du joueur (Turn == pair)
		if Turn%2 == 0 {
			fmt.Printf("🎯 Tour %d — À ton tour %s !\n", TrueTurn, c.Name)
			//Déroulement du tour du joueur
			CharacterTurn(c, e)
			//Vérification de la mort
			if EnemyIsDead(e) {
				//L'ennemi est mort
				break
			}
			Turn++
			TrueTurn++

		} else {
			//Le tour de l'IA (Turn == impair)
			fmt.Printf("🎯 Tour %d — C'est au tour de %s !\n", TrueTurn, e.Name)
			//Verification de l'effet de poison
			items.CheckPoisonStatus(e)
			if EnemyIsDead(e) {
				//L'ennemi est mort
				break
			}
			//Déroulement du tour de l'IA
			EnemyPattern(c, e, Turn)
			//Vérification de la mort
			CharacterIsDead(c)
			Turn++
			TrueTurn++
		}
	}
	//Fin du combat (ennemi mort)
	fmt.Printf("🏆 Bravo ! Tu as terrassé %s !\n", e.Name)
	//Récompenses du combat (Argent + Score)
	score.AddScore(c, e)
	inventory.AddMoney(c, e)
	character.AddExp(c, e)
	fmt.Printf("\n💰 +%d argent", e.GiveMoney)
	fmt.Printf("\n📚 +%d expérience", e.GiveExp)
	fmt.Printf("\n⭐ +%d points de score\n", e.GiveScore)
	//Affichage de l'argent, de l'Exp et du score
	affichage.Separator()
	character.NextLevel(c)
	fmt.Printf("💵 Argent : %d | 📖 Exp : %d | 🏅 Score : %d\n", c.Money, c.ActualExp, c.Score)
	affichage.Separator()
	// Retour au menu principal
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\forgeron\forgeron.go
package forgeron

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/inventory"
	"projet-red_PIZZA-BATTLE/structures"
)

// Fonction utilitaire pour obtenir le minimum entre deux entiers
func min(a, b int) int {
	// Retourne le plus petit des deux entiers
	if a < b {
		return a
	}
	return b
}

// Forgeron permet au joueur de fabriquer des objets s'il a les matériaux nécessaires
func Forgeron(c *structures.Character) {
	// Initialisation des objets nécessaires à la fabrication et des objets fabriqués
	// Objets nécessaires
	wolfFur := structures.Object{Name: "Peau de Loup", Quantity: 1}
	trollSkin := structures.Object{Name: "Peau de Troll", Quantity: 1}
	boarLeather := structures.Object{Name: "Cuir de Sanglier", Quantity: 1}
	ravenFeather := structures.Object{Name: "Plume de Corbeau", Quantity: 1}

	// Objets fabriqués
	chapeauAventurier := structures.Object{Name: "Chapeau de l'aventurier", Quantity: 1}
	tuniqueAventurier := structures.Object{Name: "Tunique de l'aventurier", Quantity: 1}
	bottesAventurier := structures.Object{Name: "Bottes de l'aventurier", Quantity: 1}

	// Initialisation des variables pour les choix du joueur
	var forgeron_choice int
	var craft_confirmation int

	// Boucle principale du forgeron
	for {
		fmt.Println("======== Forgeron : ========")
		fmt.Println("Bonjour je suis le Forgeron, quel est votre choix ?")
		fmt.Println("1 - Fabrication : Chapeau de l'aventurier (1 Plume de Corbeau + 1 Cuir de Sanglier)")
		fmt.Println("2 - Fabrication : Tunique de l'aventurier (2 Fourrures de Loup + 1 Peau de Troll)")
		fmt.Println("3 - Fabrication : Bottes de l'aventurier (1 Fourrure de Loup + 1 Cuir de Sanglier)")
		fmt.Println("4 - RETOUR")
		fmt.Scan(&forgeron_choice)

		// Initialisation des compteurs pour chaque matériau
		var countRavenFeather, countBoarLeather, countWolfFur, countTrollSkin int

		// Comptage des matériaux dans l'inventaire du personnage
		for i := range c.Inventory {
			switch c.Inventory[i].Name {
			case "Plume de Corbeau":
				countRavenFeather = c.Inventory[i].Quantity
			case "Cuir de Sanglier":
				countBoarLeather = c.Inventory[i].Quantity
			case "Peau de Loup":
				countWolfFur = c.Inventory[i].Quantity
			case "Peau de Troll":
				countTrollSkin = c.Inventory[i].Quantity
			}
		}

		// Gestion des choix du joueur pour la fabrication
		switch forgeron_choice {
		case 1:
			// Fabrication du Chapeau de l'aventurier
			// Calcul du nombre d'objets fabriquables en fonction des matériaux disponibles
			itemcraftable := min(countRavenFeather, countBoarLeather)
			//Vérification si le joueur a les matériaux nécessaires
			if itemcraftable < 1 {
				fmt.Printf("\n❌ Tu n'as pas les objets requis pour fabriquer le Chapeau de l'Aventurier\n\n")
				// Il n'a pas les matériaux nécessaires, retour au menu
				break
			} else {
				// Il a les matériaux nécessaires, affiche le nombre d'objets fabriquables
				fmt.Printf("\nTu peux fabriquer %dx Chapeau de l'Aventurier, veux-tu en fabriquer 1 ?\n", itemcraftable)
			}

			// Demande de confirmation au joueur avant de fabriquer l'objet
			// 1 = Oui, 2 = Non
			fmt.Println("1 - Oui je suis sûr !")
			fmt.Println("2 - Non je ne suis pas sûr, retour !")
			fmt.Scan(&craft_confirmation)
			switch craft_confirmation {
			case 1:
				// Fabrication du chapeau
				fmt.Println("\nTu viens de fabriquer", itemcraftable, "x Chapeau de l'Aventurier")
				// Retrait des matériaux de l'inventaire
				inventory.RemoveInventory(c, ravenFeather)
				inventory.RemoveInventory(c, boarLeather)
				// Ajout du chapeau à l'inventaire
				inventory.AddInventory(c, chapeauAventurier)
			case 2:
				// Retour au menu précédent sans fabriquer l'objet
				fmt.Printf("\nRetour au menu précédent\n")
			}

		case 2:
			// Fabrication de la Tunique de l'aventurier
			//besoin de 2 fourrures de loup + 1 peau de troll
			itemcraftable := min(countWolfFur/2, countTrollSkin)
			if itemcraftable < 1 {
				fmt.Printf("\n❌ Tu n'as pas les objets requis pour Tunique de l'aventurier de l'Aventurier\n\n")
				break
			} else {
				fmt.Printf("\nTu peux fabriquer %dx Chapeau de l'Aventurier, veux-tu en fabriquer 1 ?\n", itemcraftable)
			}

			fmt.Println("1 - Oui je suis sûr !")
			fmt.Println("2 - Non je ne suis pas sûr, retour !")
			fmt.Scan(&craft_confirmation)
			switch craft_confirmation {
			case 1:
				// Fabrication de la tunique, retrait des matériaux et ajout à l'inventaire
				fmt.Printf("\nTu viens de fabriquer %d x Tunique de l'Aventurier\n\n", itemcraftable)
				inventory.RemoveInventory(c, wolfFur)
				inventory.RemoveInventory(c, wolfFur) //Retire 2 fourrures de loup
				inventory.RemoveInventory(c, trollSkin)
				inventory.AddInventory(c, tuniqueAventurier)
			case 2:
				// Retour au menu précédent sans fabriquer l'objet
				fmt.Printf("\nRetour au menu précédent\n\n")
			}

		case 3:
			// Fabrication des Bottes de l'aventurier
			itemcraftable := min(countWolfFur, countBoarLeather)
			if itemcraftable < 1 {
				fmt.Printf("\n❌ Tu n'as pas les objets requis pour Bottes de l'aventurier de l'Aventurier\n\n")
				break
			} else {
				fmt.Printf("\nTu peux fabriquer %dx Chapeau de l'Aventurier, veux-tu en fabriquer 1 ?\n", itemcraftable)
			}

			fmt.Println("1 - Oui je suis sûr !")
			fmt.Println("2 - Non je ne suis pas sûr, retour !")
			fmt.Scan(&craft_confirmation)
			switch craft_confirmation {
			case 1:
				// Fabrication des bottes, retrait des matériaux et ajout à l'inventaire
				fmt.Printf("\nTu viens de fabriquer %d x Bottes de l'Aventurier\n\n", itemcraftable)
				inventory.RemoveInventory(c, wolfFur)
				inventory.RemoveInventory(c, boarLeather)
				inventory.AddInventory(c, bottesAventurier)
			case 2:
				// Retour au menu précédent sans fabriquer l'objet
				fmt.Printf("\nRetour au menu précédent\n")
			}

		case 4:
			// Retour au menu précédent
		}
		if forgeron_choice == 4 {
			forgeron_choice = 0
			break
		}
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\inventory\inventory.go
package inventory

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/structures"
)

// AddInventory ajoute un objet à l'inventaire du personnage, en augmentant la quantité si l'objet existe déjà
func AddInventory(c *structures.Character, newObj structures.Object) {
	for i := range c.Inventory {
		if c.Inventory[i].Name == newObj.Name {
			c.Inventory[i].Quantity += newObj.Quantity
			return
		}
	}
	c.Inventory = append(c.Inventory, newObj)
}

// RemoveInventory retire un objet de l'inventaire du personnage, en diminuant la quantité
// ou en supprimant l'objet si la quantité atteint zéro
func RemoveInventory(c *structures.Character, obj structures.Object) {
	for i := range c.Inventory {
		if c.Inventory[i].Name == obj.Name {
			if c.Inventory[i].Quantity > obj.Quantity {
				c.Inventory[i].Quantity -= obj.Quantity
			} else {
				c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
			}
			return
		}
	}
}

// AddEquipment équipe un objet d'armure au personnage, en remplaçant l'armure existante si nécessaire
func AddEquipment(c *structures.Character, newObj structures.Object) {
	// Équipe l'armure en fonction de son type (tête, torse, jambes)
	switch newObj.Name {
	case "Chapeau de l'aventurier":
		// Vérifie si l'armure de tête est déjà équipée
		if c.Armor.Head.Name != "Chapeau de l'aventurier" {
			// Si l'armure de tête n'est pas équipée, l'équipe
			c.Armor.Head = &newObj
			fmt.Printf("\nTu équipes : Chapeau de l'aventurier\n\n")
			fmt.Printf("\nTu gagnes + 10 PV Max\n\n")
			fmt.Printf("%d/%d PV -> %d/%d PV\n\n", c.ActualHp, c.MaxHp, c.ActualHp, c.MaxHp+10)
			// Augmente les PV max du personnage de 10
			c.MaxHp += 10
			// Retire l'objet de l'inventaire
			RemoveInventory(c, newObj)
		} else {
			// Si l'armure de tête est déjà équipée, affiche un message et ne fait rien
			fmt.Printf("\n❌ Tu as déjà équipé : %s\n\n", newObj.Name)
		}
	case "Tunique de l'aventurier":
		// Vérifie si l'armure de torse est déjà équipée, si ce n'est pas le cas, l'équipe
		// et augmente les PV max de 25
		if c.Armor.Chest.Name != "Tunique de l'aventurier" {
			c.Armor.Chest = &newObj
			fmt.Printf("\nTu équipes : Tunique de l'aventurier\n\n")
			fmt.Printf("\nTu gagnes + 25 PV Max\n\n")
			fmt.Printf("%d/%d PV -> %d/%d PV\n\n", c.ActualHp, c.MaxHp, c.ActualHp, c.MaxHp+25)
			c.MaxHp += 25
			RemoveInventory(c, newObj)
		} else {
			fmt.Printf("\n❌ Tu as déjà équipé : %s\n\n", newObj.Name)
		}
	case "Bottes de l'aventurier":
		// Vérifie si l'armure de jambes est déjà équipée, si ce n'est pas le cas, l'équipe
		// et augmente les PV max de 15
		if c.Armor.Legs.Name != "Bottes de l'aventurier" {
			c.Armor.Legs = &newObj
			fmt.Printf("\nTu équipes : Bottes de l'aventurier\n\n")
			fmt.Printf("\nTu gagnes + 15 PV Max\n\n")
			fmt.Printf("%d/%d PV -> %d/%d PV\n\n", c.ActualHp, c.MaxHp, c.ActualHp, c.MaxHp+15)
			c.MaxHp += 15
			RemoveInventory(c, newObj)
		} else {
			fmt.Printf("\n❌ Tu as déjà équipé : %s\n\n", newObj.Name)
		}
	}
}

// Fonction pour ajouter de l'argent au personnage en fonction de la difficulté de l'ennemi vaincu
func AddMoney(c *structures.Character, e *structures.Enemy) {
	c.Money += e.GiveMoney
}

// CheckMaxInventory vérifie si l'inventaire du personnage a de la place pour ajouter de nouveaux objets
// True = Il y a de la place, False = Inventaire plein
func CheckMaxInventory(c *structures.Character) bool {
	counter := 0
	for i := range c.Inventory {
		counter = counter + c.Inventory[i].Quantity
	}
	return counter < c.MaxInv
}

// UpgradeInventorySlot augmente la capacité maximale de l'inventaire du personnage de 10 emplacements
func UpgradeInventorySlot(c *structures.Character) {
	c.MaxInv = c.MaxInv + 10
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\items\items.go
package items

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/structures"
)

// Fonction pour utiliser une potion de vie
func TakePot(c *structures.Character) {
	// Définir le nom de la potion de vie
	HpPot := structures.Object{Name: "Potion de Vie"}
	// Vérifier si le personnage a déjà les PV max
	if c.ActualHp == c.MaxHp {
		fmt.Printf("\nLes points de vie sont déjà au max\n\n")
		// Ne rien faire
		return
	}
	// Parcourir l'inventaire du personnage pour trouver la potion de vie
	for i := 0; i < len(c.Inventory); i++ {
		// Si la potion de vie est trouvée
		if c.Inventory[i].Name == HpPot.Name {
			// Augmenter les PV actuels du personnage de 50
			c.ActualHp += 50
			// Réduire la quantité de la potion de vie dans l'inventaire
			c.Inventory[i].Quantity--
			// Si la quantité de la potion de vie est égale à 0, la retirer de l'inventaire
			if c.Inventory[i].Quantity == 0 {
				c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
			}
			// Si les PV actuels dépassent les PV max, les ramener aux PV max
			if c.ActualHp >= c.MaxHp {
				c.ActualHp = c.MaxHp
			}
			// Afficher un message indiquant que la potion a été consommée et les PV actuels
			fmt.Printf("\nPotion consommée ! +50 PV\n")
			fmt.Printf("PV actuels: %d\n", c.ActualHp)
			// Sortir de la fonction
			return
		}
	}
	// Si la potion de vie n'est pas trouvée dans l'inventaire, afficher un message d'erreur
	fmt.Println("❌ Il n'y a pas de potions de Vie dans l'inventaire")
}

func CheckPoisonStatus(e *structures.Enemy) {
	if e.Poisoned && e.PoisonTurns > 0 {
		e.ActualHp -= e.PoisonDamage
		fmt.Printf("☠️ %s subit %d dégâts de poison (%d tours restants)\n", e.Name, e.PoisonDamage, e.PoisonTurns)
		e.PoisonTurns--

		if e.PoisonTurns == 0 {
			e.Poisoned = false
			fmt.Println("✅ Le poison s’est dissipé.")
		}
	}

}

// Fonction pour utiliser une potion de mana
// A FINIR
func TakeManaPot(c *structures.Character) {
	ManaPot := structures.Object{Name: "Potion de Mana"}
	if c.ActualMana == c.ManaMax {
		fmt.Printf("\nLes points de vie sont déjà au max\n\n")
		return
	}
	for i := 0; i < len(c.Inventory); i++ {
		if c.Inventory[i].Name == ManaPot.Name {
			c.ActualHp += 20
			c.Inventory[i].Quantity--
			if c.Inventory[i].Quantity == 0 {
				c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
			}
			if c.ActualMana >= c.ManaMax {
				c.ActualMana = c.ManaMax
			}
			fmt.Printf("\nPotion consommée !\n")
			fmt.Printf("Mana actuel: %d\n", c.ActualMana)

			return
		}
	}
	fmt.Println("❌Il n'y a pas de potions de Mana dans l'inventaire")
}

// Fonction pour utiliser une potion de poison
// A FINIR (effet sur plusieurs tours)
func ThrowPoisonPot(c *structures.Character, e *structures.Enemy) {
	// Définir le nom de la potion de poison
	PoisonPot := structures.Object{Name: "Potion de Poison"}
	// Parcourir l'inventaire du personnage pour trouver la potion de poison, si trouvée l'utiliser, la retirer
	// et infliger des dégâts sur plusieurs tours à l'ennemi
	for i := 0; i < len(c.Inventory); i++ {
		if c.Inventory[i].Name == PoisonPot.Name {
			if c.Inventory[i].Quantity == 0 {
				c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
				e.ActualHp -= 10
				c.Inventory[i].Quantity--
			}
			// Effet de la potion de poison sur 3 tours (10 dégâts par tour)
			//A FINIR (ajouter un effet de poison sur plusieurs tours)
			fmt.Printf("\nPotion envoyée !\n")

			// Appliquer l’effet poison
			e.Poisoned = true
			e.PoisonTurns = 3   // dure 3 tours
			e.PoisonDamage = 10 // 10 dégâts par tour

			fmt.Println("\n💀 L'ennemi est empoisonné pour 3 tours !")
			return
		}
	}
	fmt.Println("❌ Il n'y a pas de potion de poison dans l'inventaire.")
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\main.go
package main

import (
	"fmt"
	"os"
	"projet-red_PIZZA-BATTLE/affichage"
	"projet-red_PIZZA-BATTLE/character"
	"projet-red_PIZZA-BATTLE/combat"
	"projet-red_PIZZA-BATTLE/forgeron"
	"projet-red_PIZZA-BATTLE/marchand"
	"projet-red_PIZZA-BATTLE/structures"
)

// main est le point d'entrée du programme
func main() {
	// Initialisation du choix du menu
	var menuChoice int

	// Boucle principale du jeu
	for {
		// Affichage du menu de démarrage
		affichage.AffichageMenuDemarrage()
		fmt.Scan(&menuChoice)
		switch menuChoice {
		case 1:
			// On lance une nouvelle partie

			// Initialisation des statistiques, de l'inventaire et des compétance de l'ennemi
			c1 := structures.InitCharacter()

			// Création du personnage par l'utilisateur
			character.CharacterCreation(c1)

			// Initialisation de l'ennemi
			e1 := structures.InitEnemy("Petit Giovanni", "Facile")

			// Boucle du menu principal
			for {
				affichage.AffichageMenuPrincipal()
				fmt.Scan(&menuChoice)

				switch menuChoice {
				case 1:
					// Afficher les infos du personnage
					character.DisplayCInfo(c1)
				case 2:
					// Menu Inventaire
					character.InventoryChoice(c1)
				case 3:
					// Combat en 1 contre 1
					combat.TurnCombat1v1(c1, e1)
				case 4:
					// Marchand
					marchand.Marchand(c1)
				case 5:
					// Forgeron
					forgeron.Forgeron(c1)
				case 6:
				default:
					// Choix invalide
					fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
				}
				// Reset de la variable menuChoice pour éviter les boucles infinies
				if menuChoice == 6 {
					menuChoice = 0
					// Retour au menu précédent (menu de démarrage)
					break
				}

			}
		case 2:
			// Quitter le jeu
			os.Exit(0)
		default:
			// Choix invalide
			fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
		}
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\marchand\marchand.go
package marchand

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/affichage"
	"projet-red_PIZZA-BATTLE/character"
	"projet-red_PIZZA-BATTLE/inventory"
	"projet-red_PIZZA-BATTLE/skills"
	"projet-red_PIZZA-BATTLE/structures"
)

// Marchand permet au joueur d'acheter des objets et compétences s'il a assez d'argent
func Marchand(c *structures.Character) {
	//Initialisation des objets et compétences vendus par le marchand
	var marchand_choice int

	//Objets
	HpPot := structures.Object{Name: "Potion de Vie", Quantity: 1}
	ManaPot := structures.Object{Name: "Potion de Vie", Quantity: 1}
	PoisonPot := structures.Object{Name: "Potion de Poison", Quantity: 1}
	WolfFur := structures.Object{Name: "Peau de Loup", Quantity: 1}
	TrollSkin := structures.Object{Name: "Peau de Troll", Quantity: 1}
	BoarLeather := structures.Object{Name: "Cuir de Sanglier", Quantity: 1}
	RavenFeather := structures.Object{Name: "Plume de Corbeau", Quantity: 1}

	//Compétences
	FireBall := structures.Skill{Name: "Boule de feu", Damage: 20, ManaCost: 20}
	DeathSpell := structures.Skill{Name: "Sort de la mort qui tue", Damage: 500}

	//Boucle principale du marchand
	for {
		//Menu du marchand
		affichage.Separator()
		fmt.Println("🛒 Bienvenue chez le Marchand !")
		affichage.Separator()
		fmt.Println("Que veux-tu acheter ?")
		fmt.Printf("1 - 🧪 %s - 3💰\n", HpPot.Name)
		fmt.Printf("2 - ☠️  %s - 6💰\n", PoisonPot.Name)
		fmt.Printf("3 - 🔮 %s - 4💰\n", ManaPot.Name)
		fmt.Printf("4 - 📖 Livre de Sort : %s - 25💰\n", FireBall.Name)
		fmt.Printf("5 - 🐺 %s - 4💰\n", WolfFur.Name)
		fmt.Printf("6 - 👹 %s - 7💰\n", TrollSkin.Name)
		fmt.Printf("7 - 🐗 %s - 3💰\n", BoarLeather.Name)
		fmt.Printf("8 - 🪶 %s - 1💰\n", RavenFeather.Name)
		fmt.Printf("9 - 📦 Agrandir inventaire (+10 emplacements) - 30💰\n")
		fmt.Println("10 - ⬅️ Retour")
		// Test
		fmt.Printf("11 - 📖 Livre de Sort : %s - 50💰 (test)\n", DeathSpell.Name)
		// Fin test

		affichage.Separator()
		fmt.Print("👉 Ton choix : ")
		fmt.Scan(&marchand_choice)
		switch marchand_choice {
		case 1:
			// Achat d'une potion de vie
			// Vérification de la place dans l'inventaire
			if inventory.CheckMaxInventory(c) {
				// Ajout de l'objet dans l'inventaire
				inventory.AddInventory(c, HpPot)
				// Déduction de l'argent
				c.Money -= 3
				// Message de confirmation
				fmt.Println("✅ Tu as acheté une Potion de Vie (-3💰)")
				// Affichage de l'argent restant
				fmt.Println("Tu as maintenant", c.Money, "💰")
				// Affichage de l'inventaire
				character.AccessInventory(c)
				// Retour au menu du marchand
			} else {
				// Message d'erreur si l'inventaire est plein
				fmt.Printf("\n❌ Il n'y a pas assez de place dans l'inventaire\n\n")
				// Affichage de l'inventaire
				character.AccessInventory(c)
				// Retour au menu du marchand
			}
		case 2:
			// Achat d'une potion de poison
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, PoisonPot)
				c.Money -= 6
				fmt.Println("✅ Tu as acheté une Potion de Poison (-6💰)")
				fmt.Println("Tu as maintenant", c.Money, "💰")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\n❌ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 3:
			// Achat d'une potion de mana
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, ManaPot)
				c.Money -= 4
				fmt.Println("✅ Tu as acheté une Potion de Mana (-4💰)")
				fmt.Println("Tu as maintenant", c.Money, "💰")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\n❌ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 4:
			// Achat d'un livre de sort (compétence)
			// Vérification si le personnage possède déjà la compétence
			if !skills.CheckSkills(c, FireBall) {
				// Ajout de la compétence au personnage
				skills.AddSkills(c, FireBall)
				c.Money -= 25
				fmt.Printf("✅ Tu as acheté un Livre de Sort : %s (-25💰)\n", FireBall.Name)
				// Affichage de la compétence apprise
				fmt.Printf("🔥 Nouvelle compétence : %s (%d dégâts)\n", FireBall.Name, FireBall.Damage)
				fmt.Println("Tu as maintenant", c.Money, "💰")
				character.AccessInventory(c)
			} else {
				fmt.Print("\n❌ Tu possèdes déjà cette compétence\n\n")
				character.AccessInventory(c)
			}
		case 5:
			// Achat d'une fourrure de loup
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, WolfFur)
				c.Money -= 4
				fmt.Println("✅ Tu as acheté une Peau de Loup (-4💰)")
				fmt.Println("Tu as maintenant", c.Money, "💰")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\n❌ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 6:
			// Achat d'une peau de troll
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, TrollSkin)
				c.Money -= 7
				fmt.Println("✅ Tu as acheté une Peau de Troll (-7💰)")
				fmt.Println("Tu as maintenant", c.Money, "💰")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\n❌ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 7:
			// Achat d'un cuir de sanglier
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, BoarLeather)
				c.Money -= 3
				fmt.Println("✅ Tu as acheté un Cuir de Sanglier (-3💰)")
				fmt.Println("Tu as maintenant", c.Money, "💰")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\n❌ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}
		case 8:
			// Achat d'une plume de corbeau
			if inventory.CheckMaxInventory(c) {
				inventory.AddInventory(c, RavenFeather)
				c.Money -= 1
				fmt.Println("✅ Tu as acheté une Plume de Corbeau (-1💰)")
				fmt.Println("Tu as maintenant", c.Money, "💰")
				character.AccessInventory(c)
			} else {
				fmt.Printf("\n❌ Il n'y a pas assez de place dans l'inventaire\n\n")
				character.AccessInventory(c)
			}

		case 9:
			// Achat d'une augmentation de l'inventaire
			c.Money -= 30
			fmt.Println("✅ Ton inventaire s'est agrandi de 10 places (-30💰)")
			fmt.Println("Tu as maintenant", c.Money, "💰")
			// Augmentation de la taille de l'inventaire de 10 slots
			inventory.UpgradeInventorySlot(c)

		case 10:
			// Retour au menu précédent
		case 11:
			// Test achat d'un livre de sort (compétence)
			if !skills.CheckSkills(c, DeathSpell) {
				skills.AddSkills(c, DeathSpell)
				fmt.Printf("✅ Tu as acheté un Livre de Sort : %s (-50💰)\n", DeathSpell.Name)
				fmt.Printf("💀 Nouvelle compétence : %s (%d dégâts)\n", DeathSpell.Name, DeathSpell.Damage)
				fmt.Println("Tu as maintenant", c.Money, "💰")
				character.AccessInventory(c)
			} else {
				fmt.Print("\n❌ Tu possèdes déjà cette compétence\n\n")
				character.AccessInventory(c)
			}
		default:
			// Choix autre que 1 à 10
			fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
		}
		// Retour au menu précédent si le choix est 10
		// Reset de la variable marchand_choice si le choix est 10
		// Permet de ne pas rester bloqué dans la boucle du marchand
		if marchand_choice == 10 {
			marchand_choice = 0
			break
		}
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\score\score.go
package score

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/structures"
)

// AddScore ajoute des points au score du personnage en fonction de la difficulté de l'ennemi vaincu
func AddScore(c *structures.Character, e *structures.Enemy) {
	c.Score += e.GiveScore
}

// ShowScore affiche le score actuel du personnage
func ShowScore(c *structures.Character) {
	fmt.Printf("\n\nScore de %s : %d\n\n", c.Name, c.Score)
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\skills\skills.go
package skills

import (
	"fmt"
	"projet-red_PIZZA-BATTLE/structures"
)

// AddSkills ajoute une compétence à la liste des compétences du personnage
func AddSkills(c *structures.Character, newSkill structures.Skill) {
	c.SkillList = append(c.SkillList, newSkill)
}

// CheckSkills vérifie si le personnage a déjà la compétence
func CheckSkills(c *structures.Character, newSkill structures.Skill) bool { //True = Il a déjà la comp.
	for i := range c.SkillList {
		if c.SkillList[i].Name == newSkill.Name {
			return true
		}
	}
	return false
}

// SkillChoice permet au joueur de choisir une compétence à utiliser et retourne la compétence choisie
func SkillChoice(c *structures.Character) structures.Skill {
	var skill_choice int
	// Affiche la liste des compétences disponibles
	for {
		fmt.Println("\nQuelle compétence veux-tu utiliser ?")
		for i := range c.SkillList {
			fmt.Printf("%d - %s\n", i+1, c.SkillList[i].Name)
		}
		fmt.Print("👉 Ton choix : ")
		fmt.Scan(&skill_choice)
		// Vérifie que le choix est valide dans la liste des compétences
		if skill_choice >= 1 && skill_choice <= len(c.SkillList) {
			// Retourne la compétence choisie (indexée à partir de 0)
			return c.SkillList[skill_choice-1]
		}
		// Si le choix n'est pas valide, affiche un message d'erreur et redemande
		fmt.Printf("\n❌ Il ne se passe rien... Choix invalide.\n")
	}
}

// UseSkill applique les effets de la compétence sur les pv de l'ennemi
func UseSkill(c *structures.Character, e *structures.Enemy, skill structures.Skill) {
	e.ActualHp -= skill.Damage
}

// CheckMana vérifie si le personnage a assez de mana pour utiliser une compétence
func CheckMana(c *structures.Character, skill structures.Skill) {
	if c.ActualMana < skill.ManaCost {
		fmt.Println("Vous n'avez pas assez de mana pour lancer ce sort")
	}

}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\src\structures\structures.go
package structures

// Object représente un objet dans l'inventaire ou l'équipement
type Object struct {
	Name     string
	Quantity int
}

// Character représente un personnage joueur avec ses attributs et son inventaire
type Character struct {
	Name       string
	Class      string
	Level      int
	MaxHp      int
	ActualHp   int
	Inventory  []Object
	MaxInv     int
	Money      int
	SkillList  []Skill
	Armor      Equipment
	Score      int
	Initiative int
	ActualExp  int
	MaxExp     int
	ActualMana int
	ManaMax    int
}

// Enemy représente un ennemi avec ses attributs
type Enemy struct {
	Name         string
	MaxHp        int
	ActualHp     int
	Damage       int
	Difficulty   string //3 types : Facile= score 5, Normale= score 10, Boss= score 20
	Initiative   int
	PowerCount   int
	GiveScore    int
	GiveMoney    int
	GiveExp      int
	Poisoned     bool
	PoisonTurns  int
	PoisonDamage int
}

// Skill représente une compétence que le personnage peut utiliser en combat
type Skill struct {
	Name     string
	Damage   int
	ManaCost int
}

// Equipment représente l'équipement porté par le personnage
type Equipment struct {
	Head  *Object //Pointeur unique vide de structure Objects
	Chest *Object //Un équipement pour le torse
	Legs  *Object //Un équipement pour les pieds

}

// InitCharacter initialise un personnage avec des valeurs par défaut sans nom ni classe (définis par CharacterCreation)
func InitCharacter() *Character {
	return &Character{
		Level:      1,
		ActualExp:  0,
		MaxExp:     100,
		Initiative: 100,
		// Initialisation avec 3 potions
		Inventory: []Object{
			{Name: "Potion de Vie", Quantity: 3},
		},
		ActualHp: 100,
		MaxInv:   10,
		Money:    100,
		// Initialisation de la compétance de base
		SkillList: []Skill{
			{Name: "Coup de poing", Damage: 10, ManaCost: 0},
		},
		// Initialisation de l'armure (rien d'éauipé)
		Armor: Equipment{
			Head:  &Object{Name: ""},
			Chest: &Object{Name: ""},
			Legs:  &Object{Name: ""},
		},
		//Score de fin de partie
		Score: 0,
	}
}

// InitEnemy initialise un Ennemi avec des valeurs donnée selon la difficulté donnée et les valeurs données
func InitEnemy(name string, grade string) *Enemy {
	switch grade {
	// si La difficulté donnée est "Facile"
	case "Facile":

		return &Enemy{
			Name:       name,
			MaxHp:      100,
			ActualHp:   100,
			Damage:     5,
			Difficulty: "Facile",
			Initiative: 100,
			PowerCount: 0,
			GiveScore:  5,
			GiveMoney:  5,
			GiveExp:    100,
		}
		// si La difficulté donnée est "Normale"
	case "Normale":

		return &Enemy{
			Name:       name,
			MaxHp:      120,
			ActualHp:   120,
			Damage:     15,
			Difficulty: "Normal",
			Initiative: 120,
			PowerCount: 0,
			GiveScore:  10,
			GiveMoney:  10,
			GiveExp:    150,
		}
		// si La difficulté donnée est "Boss"
	case "Boss":

		return &Enemy{
			Name:       name,
			MaxHp:      200,
			ActualHp:   200,
			Damage:     25,
			Difficulty: "Boss",
			Initiative: 150,
			PowerCount: 0,
			GiveScore:  5,
			GiveMoney:  5,
			GiveExp:    300,
		}
	}
	// si La difficulté donnée est rien, initialise quand même un ennemi "Facile"
	return &Enemy{
		Name:       name,
		MaxHp:      100,
		ActualHp:   100,
		Damage:     5,
		Difficulty: "Facile",
		Initiative: 100,
		PowerCount: 0,
		GiveScore:  5,
		GiveMoney:  5,
		GiveExp:    100,
	}
}

//Initialise une compétence utilisable dans la liste des compétences
func InitSkill(name string, damage int) *Skill {
	return &Skill{
		Name:   name,
		Damage: damage,
	}

}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\test.go
package main

import (
	"fmt"
	"math/rand"
)

var choix int

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func rollDice() int {
	return rand.Intn(100) + 1
}

func main() {

	fmt.Println("🟩⬜🟥 Épreuve de la Mamma : choisissez un nombre, celui le plus proche du score de la Mamma commence.")

	// input joueur sécurisé
	for {
		fmt.Print("Entrez votre nombre (1-100) : ")
		_, err := fmt.Scan(&choix)
		if err == nil && choix >= 1 && choix <= 100 {
			break
		}
		fmt.Println("Valeur invalide ! Tapez un nombre entre 1 et 100.")
	}

	// premier lancer
	mamma := rollDice()
	ennemi := rollDice()

	// affichage clair
	fmt.Printf("Ton Chiffre : %d | Chiffre de la Mamma : %d | Chiffre de l'ennemi : %d\n", choix, mamma, ennemi)

	// en cas d'égalité
	for choix == ennemi {
		fmt.Println("Égalité — relance des dés !")
		mamma = rollDice()
		ennemi = rollDice()
		fmt.Printf("Chiffre : %d | Chiffre de la Mamma : %d | Chiffre de l'ennemi : %d\n", choix, mamma, ennemi)
	}

	// distances absolues
	distJoueur := abs(choix - mamma)
	distEnnemi := abs(ennemi - mamma)

	// initiative
	if distJoueur < distEnnemi {
		fmt.Printf("✅ Vous êtes le plus proche du chiffre de la Mamma avec une distance de %d, vous commencez !\n", distJoueur)
		initiative = initiative + distJoueur
		fmt.Printf("Vous avez %d\n", initiative)
	} else {
		fmt.Printf("❌ L'ennemi le plus proche du chiffre de la Mamma avec une distance de %d, il commence !\n", distEnnemi)
		initiative = initiative - distEnnemi
		fmt.Printf("Vous avez %d\n", initiative)
	}
}


///

// FILE: C:\Users\harol\Documents\Cours\Projet RED\projet-red_PIZZA-BATTLE\text.go
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	// Chemin spécifique du projet
	projectPath := "C:\\Users\\harol\\Documents\\Cours\\Projet RED\\projet-red_PIZZA-BATTLE"
	outputFile := "project_files.txt"

	// Store all file contents
	var allContents []string

	// Walk through the directory
	err := filepath.Walk(projectPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories and non-go files
		if info.IsDir() || !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		// Skip the output file itself
		if info.Name() == outputFile {
			return nil
		}

		// Read file content
		content, err := ioutil.ReadFile(path)
		if err != nil {
			fmt.Printf("Error reading file %s: %v\n", path, err)
			return nil // Continue with other files
		}

		// Add file path and content to collection
		fileEntry := fmt.Sprintf("// FILE: %s\n%s", path, string(content))
		allContents = append(allContents, fileEntry)
		fmt.Printf("Added file: %s\n", path)

		return nil
	})

	if err != nil {
		fmt.Printf("Error walking directory: %v\n", err)
		return
	}

	// Join all contents with separator
	joinedContent := strings.Join(allContents, "\n\n///\n\n")

	// Write to output file
	err = ioutil.WriteFile(outputFile, []byte(joinedContent), 0644)
	if err != nil {
		fmt.Printf("Error writing to output file: %v\n", err)
		return
	}

	fmt.Printf("\nSuccess! All Go files from %s combined into %s\n", projectPath, outputFile)
}
